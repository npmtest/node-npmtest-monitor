{"/home/travis/build/npmtest/node-npmtest-monitor/test.js":"/* istanbul instrument in package npmtest_monitor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-monitor/lib.npmtest_monitor.js":"/* istanbul instrument in package npmtest_monitor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_monitor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_monitor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-monitor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-monitor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_monitor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_monitor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_monitor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_monitor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_monitor.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_monitor.__dirname + '/lib.npmtest_monitor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/index.js":"// index.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  /*\n  * Entry point for commonJS style loading\n  *\n  * This file coordinates the loading of modules in a consistent order\n  * in a commonJS environment.\n  */\n\n  var commonJS = (typeof exports !== 'undefined');\n  if (commonJS) {\n\n    // Only load once\n    if (global.Monitor) {\n      module.exports = global.Monitor;\n    }\n    else {\n\n      // Export the Monitor class to module and global scope to assure\n      // a single load, and to match the browser-side global Monitor.\n      var Monitor = global.Monitor = module.exports = require('./Monitor');\n\n      // Attach backbone callbacks\n      require('backbone-callbacks').attach(Monitor.Backbone);\n\n      // Grunt.js contains the module definition files\n      var MODULE_DEF = require('../grunt.js').MODULE_DEF;\n\n      // Load local library files, then server-only probes\n      var allFiles = MODULE_DEF.lib.concat(MODULE_DEF.probes);\n      allFiles.forEach(function(file) {require('../' + file);});\n    }\n  }\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Monitor.js":"// Monitor.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var commonJS = (typeof exports !== 'undefined'),\n      Backbone = commonJS ? require('backbone') : root.Backbone,\n      _ = commonJS ? require('underscore')._ : root._,\n      log = null, stat = null,\n      autoStartedMonitors = [],\n      Cron = commonJS ? require('cron') : null;\n\n  // Constants\n  var DEFAULT_DEEP_COPY_DEPTH = 4;\n\n  /**\n  * Monitor a remote probe\n  *\n  * Monitor objects are the local interface to a remote <a href=\"Probe.html\">Probe</a>.\n  * The probe may be running in this process or on a remote server.\n  *\n  * In a disconnected state, the monitor object contains information about\n  * the type, attributes, and location of the probe it will monitor.\n  *\n  * In a connected state, the monitor object contains the data attributes of\n  * the probe it is monitoring, and emits change events as the probe changes\n  * state.\n  *\n  * Many monitors may be attached to a single probe.  When the probe data model\n  * changes, changes are broadcast to the connected monitors.\n  *\n  * Probes can be remotely controlled using the control() method.\n  * The control() method acts an RPC in that it accepts input arguments and\n  * returns results to the monitor initiating the request.\n  *\n  * Example:\n  *\n  *     // Connecting a monitor to a probe\n  *     var processMonitor = new Monitor({\n  *       probeClass: 'Process'\n  *     });\n  *     processMonitor.connect();\n  *\n  *     // Monitoring the probe\n  *     processMonitor.on('change', function(){\n  *       console.log('Changes:', processMonitor.getChangedAttributes());\n  *     });\n  *\n  *     // Remote control\n  *     processMonitor.control('ping', function(error, response) {\n  *       console.log('Ping response: ', response);\n  *     });\n  *\n  * Monitoring a probe on a remote server requires the ```hostName``` parameter\n  * to be set.\n  *\n  *     // Connecting to a remote monitor\n  *     var processMonitor = new Monitor({\n  *       probeClass: 'Process',\n  *       hostName: 'remote-server1'\n  *     });\n  *     processMonitor.connect();\n  *\n  * Additional parameters can be set to identify a specific server if many\n  * servers are running on the specified ```hostName```.\n  *\n  * @class Monitor\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param [model.id] {String} An optional ID to assign to the monitor\n  *     @param [model.name] {String} An optional name to assign to the monitor\n  *     @param [model.probeClass] {String} Class name of the probe this is (or will be) monitoring.\n  *     @param [model.probeName] {String} External name given to the probe.  If specified, the probe\n  *       started by this monitor can be identified by other monitors with this name.\n  *     @param [model.initParams] {Object} Initialization parameters passed to the probe during instantiation.\n  *     @param [model.hostName] {String} Hostname the probe is (or will) run on.\n  *       If not set, the Router will connect with the first host capable of running this probe.\n  *     @param [model.appName] {String} Application name the probe is (or will) run within.\n  *       If not set, the Router will disregard the appName of the process it is connecting with.\n  *     @param [model.appInstance] {String} Application instance ID the probe is (or will) run within.\n  *       If not set, the Router will disregard the appInstance of the process it is connecting with.\n  *       Application instances can (should) set the $NODE_APP_INSTANCE environment\n  *       variable prior to running to uniquely identify their unique instance within a\n  *       server or network.  If this variable is not set prior to running the\n  *       app, node-monitor will assign a unique ID among other running apps on the host.\n  *     @param model.probeId {String} ID of the probe this is monitoring (once connected). READONLY\n  *     @param model.writableAttributes {'*' or Array of String} Most probe attributes are readonly.\n  *       If a probe allows set() to be called on an attribute, that attribute name is specified\n  *       in this array (once connected).  A value of '*' signifies all attributes as writable.  READONLY\n  *     @param model.PROBE_PARAMS... {(defined by the probe)} ... all other <strong>```model```</strong> parameters are READONLY parameters of the connected probe\n  */\n  /**\n  * Receive real time notifications from the probe\n  *\n  * When the probe data model changes, all changed attributes are forwarded\n  * to monitors, triggering this event.\n  *\n  * All probe attributes are available in the monitor, and the\n  * getChangedAttributes() method returns the list of attributes changed\n  * since the last change event.\n  *\n  *     myMonitor.on('change', function(){\n  *       console.log('Changes:', myMonitor.getChangedAttributes());\n  *     });\n  *\n  * @event change\n  */\n  var Monitor = Backbone.Model.extend({\n\n    defaults: {\n      id: '',\n      name: '',\n      probeName: '',\n      probeClass: '',\n      initParams: {},\n      hostName: '',\n      appName: '',\n      appInstance: '',\n      probeId: '',\n      writableAttributes: []\n    },\n    initialize: function(params, options) {\n      log.info('init', params);\n    },\n\n    /**\n    * Connect the monitor to the remote probe\n    *\n    * Upon connection, the monitor data model is a proxy of the current state\n    * of the probe.\n    *\n    * @method connect\n    * @param callback {Function(error)} Called when the probe is connected (or error)\n    */\n    /**\n    * The monitor has successfully connected with the probe\n    * @event connect\n    */\n    connect: function(callback) {\n      var t = this, startTime = Date.now();\n      Monitor.getRouter().connectMonitor(t, function(error) {\n\n        // Monitor changes to writable attributes\n        if (!error && t.get('writableAttributes').length > 0) {\n          t.on('change', t.onChange, t);\n        }\n\n        // Give the caller first crack at knowing we're connected,\n        // followed by anyone registered for the connect event.\n        if (callback) {callback(error);}\n\n        // Initial data setting into the model was done silently\n        // in order for the connect event to fire before the first\n        // change event.  Fire the connect / change in the proper order.\n        if (!error) {\n\n          // An unfortunate side effect is any change listeners registered during\n          // connect will get triggered with the same values as during connect.\n          // To get around this, add change listeners from connect on nextTick.\n          t.trigger('connect', t);\n          t.trigger('change', t);\n\n          log.info('connected', {initParams: t.get('initParams'), probeId: t.get('probeId')});\n          stat.time('connect', Date.now() - startTime);\n        }\n      });\n    },\n\n    /**\n    * Get the connection to the remote probe\n    *\n    * This method returns the Connection object that represents the remote\n    * server used for communicating with the connected probe.\n    *\n    * If the probe is running internally or the monitor isn't currently\n    * connected, this will return null.\n    *\n    * @method getConnection\n    * @return connection {Connection} The connection object\n    */\n    getConnection: function() {\n      var t = this;\n      return (t.probe && t.probe.connection ? t.probe.connection : null);\n    },\n\n    /**\n    * Is the monitor currently connected?\n    *\n    * @method isConnected\n    * @return {boolean} True if the monitor is currently connected\n    */\n    isConnected: function() {\n      var t = this;\n      return (t.probe != null);\n    },\n\n    /**\n    * Disconnect from the remote probe\n    *\n    * This should be called when the monitor is no longer needed.\n    * It releases resources associated with monitoring the probe.\n    *\n    * If this was the last object monitoring the probe, the probe will be\n    * stopped, releasing resources associated with running the probe.\n    *\n    * @method disconnect\n    * @param callback {Function(error)} Called when disconnected (or error)\n    */\n    /**\n    * The monitor has disconnected from the probe\n    * @event disconnect\n    * @param reason {String} Reason specified for the disconnect\n    * <ul>Known Reasons:\n    *   <li>manual_disconnect - A manual call to disconnect() was made.</li>\n    *   <li>connect_failed - Underlying transport connection problem.</li>\n    *   <li>remote_disconnect - Underlying transport disconnected.</li>\n    * </ul>\n    */\n    disconnect: function(callback) {\n      var t = this,\n          reason = 'manual_disconnect',\n          startTime = Date.now(),\n          probeId = t.get('probeId');\n\n      // Stop forwarding changes to the probe\n      t.off('change', t.onChange, t);\n\n      // Disconnect from the router\n      Monitor.getRouter().disconnectMonitor(t, reason, function(error, reason) {\n        if (callback) {callback(error);}\n        if (error) {\n          log.error('disconnect', {error: error});\n        }\n        else {\n          t.trigger('disconnect', reason);\n          log.info('disconnected', {reason: reason, probeId: probeId});\n          stat.time('disconnect', Date.now() - startTime);\n        }\n      });\n    },\n\n    /**\n    * Forward changes on to the probe, when connected.\n    *\n    * This is called whenever a change trigger is fired.  It forwards any\n    * changes of writable attributes onto the probe using control('set').\n    */\n    onChange: function() {\n      var t = this,\n          writableAttributes = t.get('writableAttributes'),\n          writableChanges = {};\n\n      // Add any writable changes\n      var probeAttrs = t.toProbeJSON();\n      delete probeAttrs.id;\n      for (var attrName in probeAttrs) {\n        var isWritable = writableAttributes === '*' || writableAttributes.indexOf(attrName) >= 0;\n        if (isWritable && !(_.isEqual(t.attributes[attrName], t._probeValues[attrName]))) {\n          writableChanges[attrName] = t.attributes[attrName];\n        }\n      }\n\n      // Pass any writable changes on to control.set()\n      if (Monitor._.size(writableChanges)) {\n        t.control('set', writableChanges, function(error) {\n          if (error) {\n            log.error('probeSet', 'Problem setting writable value', writableChanges, t.toMonitorJSON());\n          }\n        });\n      }\n    },\n\n    /**\n    * Send a control message to the probe.\n    *\n    * Monitors can use this method to send a message and receive a response\n    * from a connected probe.\n    *\n    * The probe must implement the specified control method.  All probes are\n    * derived from the base <a href=\"Probe.html\">Probe</a> class, which offers\n    * a ping control.\n    *\n    * To send a ping message to a probe and log the results:\n    *\n    *     var myMonitor.control('ping', console.log);\n    *\n    * @method control\n    * @param name {String} Name of the control message.\n    * @param [params] {Object} Named input parameters specific to the control message.\n    * @param [callback] {Function(error, response)} Function to call upon return.\n    * <ul>\n    *   <li>error (Any) - An object describing an error (null if no errors)</li>\n    *   <li>response (Any) - Response parameters specific to the control message.</li>\n    * </ul>\n    */\n    control: function(name, params, callback) {\n      var t = this,\n          probe = t.probe,\n          logId = 'control.' + t.get('probeClass') + '.' + name,\n          startTime = Date.now();\n\n      // Switch callback if sent in 2nd arg\n      if (typeof params === 'function') {\n        callback = params;\n        params = null;\n      }\n\n      log.info(logId, params);\n\n      var whenDone = function(error, args) {\n        if (error) {\n          log.error(logId, error);\n        }\n        else {\n          log.info('return.' + logId, args);\n          stat.time(logId, Date.now() - startTime);\n        }\n\n        if (callback) {\n          callback.apply(t, arguments);\n        }\n      };\n\n      if (!probe) {\n        return whenDone('Probe not connected');\n      }\n\n      // Send the message internally or to the probe connection\n      if (probe.connection) {\n        probe.connection.emit('probe:control', {probeId: t.get('probeId'), name: name, params:params}, whenDone);\n      } else {\n        probe.onControl(name, params, whenDone);\n      }\n    },\n\n    /**\n    * Produce an object without monitor attributes\n    *\n    * A Monitor object contains a union of the connection attributes required for\n    * a Monitor, and the additional attributes defined by the probe it's monitoring.\n    *\n    * This method produces an object containing only the probe portion of\n    * those attributes.\n    *\n    * The id attribute of the returned JSON is set to the probeId from\n    * the monitor.\n    *\n    * @method toProbeJSON\n    * @param [options] {Object} Options to pass onto the model toJSON\n    * @return {Object} The probe attributes\n    */\n    toProbeJSON: function(options) {\n      var t = this,\n          json = {id: t.get('probeId')};\n\n      // Transfer all non-monitor attrs\n      _.each(t.toJSON(options), function(value, key) {\n        if (!(key in t.defaults)) {\n          json[key] = value;\n        }\n      });\n      return json;\n    },\n\n    /**\n    * Produce an object with the monitor only attributes.\n    *\n    * A Monitor object contains a union of the connection attributes required for\n    * a Monitor, and the additional attributes defined by the probe it's monitoring.\n    *\n    * This method produces an object containing only the monitor portion of\n    * those attributes.\n    *\n    * @method toMonitorJSON\n    * @param [options] {Object} Options to pass onto the model toJSON\n    * @return {Object} The monitor attributes\n    */\n    toMonitorJSON: function(options) {\n      var t = this,\n          json = {};\n\n      // Transfer all monitor attrs\n      _.each(t.toJSON(options), function(value, key) {\n        if (key in t.defaults) {\n          json[key] = value;\n        }\n      });\n      return json;\n    },\n\n    /**\n    * Produce a server string representation of the hostName:appName:appInstance\n    *\n    * Depending on the presence of the appName and appInstance, this will produce\n    * one of the following:\n    *\n    *     hostName\n    *     hostName:appName\n    *     hostName:appName:appInstance\n    *\n    * @method toServerString\n    * @return {String} A string representation of the monitor server\n    */\n    toServerString: function() {\n      return Monitor.toServerString(this.toMonitorJSON());\n    }\n\n  });\n\n  /////////////////////////\n  // Static helper methods\n  /////////////////////////\n\n  /**\n  * Generate a unique UUID-v4 style string\n  *\n  * This is a cross-platform UUID implementation used to uniquely identify\n  * model instances.  It is a random number based UUID, and as such can't be\n  * guaranteed unique.\n  *\n  * @static\n  * @protected\n  * @method generateUniqueId\n  * @return {String} A globally unique ID\n  */\n  Monitor.generateUniqueId = function() {\n    // Generate a 4 digit random hex string\n    stat.increment('generateUniqueId');\n    function rhs4() {return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);}\n    return (rhs4()+rhs4()+\"-\"+rhs4()+\"-\"+rhs4()+\"-\"+rhs4()+\"-\"+rhs4()+rhs4()+rhs4());\n  };\n\n  /**\n  * Generate a unique ID for a collection\n  *\n  * This generates an ID to be used for new elements of the collection,\n  * assuring they don't clash with other elements in the collection.\n  *\n  * @method Monitor.generateUniqueCollectionId\n  * @param collection {Backbone.Collection} The collection to generate an ID for\n  * @param [prefix] {String} An optional prefix for the id\n  * @return id {String} A unique ID with the specified prefix\n  */\n  Monitor.generateUniqueCollectionId = function(collection, prefix) {\n    var id = '';\n    prefix = prefix || '';\n\n    // First time - get the largest idSequence in the collection\n    if (!collection.idSequence) {\n      collection.idSequence = 0;\n      collection.forEach(function(item){\n        var id = item.get('id') || '',\n            sequence = +id.substr(prefix.length);\n        if (collection.idSequence <= sequence) {\n          collection.idSequence = sequence + 1;\n        }\n      });\n    }\n\n    return prefix + collection.idSequence++;\n  };\n\n  /**\n  * Get the default router (an application singleton)\n  *\n  * This instantiates a Router on first call.\n  *\n  * @static\n  * @protected\n  * @method getRouter\n  * @return {Router} The default router.\n  */\n  Monitor.getRouter = function() {\n\n    // Instantiate a router if no default\n    if (!Monitor.defaultRouter) {\n      Monitor.defaultRouter = new Monitor.Router();\n\n      // If there's a global socket.io server available,\n      // then we're running on the browser.  Set the default\n      // gateway to the global io socket.\n      if (root.io) {\n        Monitor.defaultRouter.setGateway({\n          socket:root.io.connect()\n        });\n      }\n    }\n\n    // Return the router\n    return Monitor.defaultRouter;\n  };\n\n  /**\n  * Start a monitor server in this process\n  *\n  * This is a shortand for the following:\n  *\n  *     var Monitor = require('monitor');\n  *     var server = new Monitor.Server();\n  *     server.start();\n  *\n  * It can be chained like this:\n  *\n  *     var Monitor = require('monitor').start(),\n  *         log = Monitor.getLogger('my-app');\n  *\n  * For more fine-tuned starting, see the <a href=\"Server.html\">Server</a> api.\n  *\n  * @static\n  * @method start\n  * @param options {Object} - Server.start() options.  OPTIONAL\n  *     @param options.port {Integer} - Port to attempt listening on if server isn't specified.  Default: 42000\n  * @param callback {Function(error)} - Called when the server is accepting connections.\n  * @return monitor {Monitor} - Returns the static Monitor class (for chaining)\n  */\n  Monitor.start = function(options, callback) {\n    log.info('start', options);\n    callback = callback || function(){};\n\n    // Get a default monitor\n    if (!Monitor.defaultServer) {\n      Monitor.defaultServer = new Monitor.Server();\n      Monitor.defaultServer.start(options, callback);\n    } else {\n      callback();\n    }\n    return Monitor;\n  };\n\n  /**\n  * Stop a started monitor server in this process\n  *\n  * @static\n  * @method stop\n  * @param callback {Function(error)} - Called when the server is accepting connections.\n  */\n  Monitor.stop = function(callback) {\n    log.info('stop');\n    callback = callback || function(){};\n    if (Monitor.defaultServer) {\n      Monitor.defaultServer.stop(callback);\n      delete Monitor.defaultServer;\n    } else {\n      callback();\n    }\n  };\n\n  /**\n  * Produce a server string representation of the hostName:appName:appInstance\n  *\n  * Depending on the presence of the appName and appInstance, this will produce\n  * one of the following:\n  *\n  *     hostName\n  *     hostName:appName\n  *     hostName:appName:appInstance\n  *\n  * @method toServerString\n  * @param monitorJSON [Object] JSON object containing the following\n  *     @param hostName {String} The host to monitor\n  *     @param [appName] {String} The app name running on the host\n  *     @param [appInstance] {String} The application instance ID running on the host\n  * @return {String} A string representation of the monitor server\n  */\n  Monitor.toServerString = function(monitorJSON) {\n    var str = monitorJSON.hostName;\n    if (monitorJSON.appName) {\n      str += ':' + monitorJSON.appName;\n      if (monitorJSON.appInstance) {\n        str += ':' + monitorJSON.appInstance;\n      }\n    }\n    return str;\n  };\n\n  /**\n  * Produce a depth-limited copy of the specified object\n  *\n  * Functions are copied for visual inspection purposes - the fact that\n  * they are a function, and any prototype members.  This is so a JSON.stringify\n  * of the result will show the functions (normally JSON.stringify doesn't output\n  * functions).\n  *\n  * This method is mostly for debugging - for producing a human-readable stream\n  * representation of the object.  It is an exact copy, except for elements of\n  * type function.\n  *\n  * @method deepCopy\n  * @param value {Mixed} Object or value to copy\n  * @param [depth=4] {Integer} Maximum depth to return.  If the depth exceeds\n  *   this value, the string \"[Object]\" is returned as the value.\n  * @return {Mixed} A depth-limited copy of the value\n  */\n  Monitor.deepCopy = function(value, depth) {\n\n    // Defaults\n    depth = typeof(depth) === 'undefined' ? DEFAULT_DEEP_COPY_DEPTH : depth;\n\n    // Simple value - return the raw value\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return value;\n    }\n\n    // Build a string representation of the type\n    var strType = '[Object]';\n    if (typeof value === 'function') {\n      strType = '[Function]';\n    } else if (Array.isArray(value)) {\n      strType = '[Array]';\n    }\n\n    // Limit reached\n    if (depth <= 0) {\n      return strType;\n    }\n\n    // Create a new object to copy into.\n    // Proactively add constructor so it's at the top of a function\n    var copy = Array.isArray(value) ? [] : {};\n\n    // Copy all elements (by reference)\n    for (var prop in value) {\n      if (!value.hasOwnProperty || value.hasOwnProperty(prop)) {\n        var elem = value[prop];\n        if (typeof elem === 'object' || typeof elem === 'function') {\n          copy[prop] = Monitor.deepCopy(elem, depth - 1);\n        }\n        else {\n          copy[prop] = elem;\n        }\n      }\n    }\n\n    // Special string formatting for functions\n    if (typeof value === 'function') {\n      if (_.isEmpty(copy)) {\n        // No sub-elements.  Identify it as a function.\n        copy = strType;\n      } else {\n        // Sub-elements exist.  Identify it as a function by placing\n        // a constructor at the top of the object\n        copy = _.extend({constructor: strType},copy);\n      }\n    }\n\n    // Return the copy\n    return copy;\n  };\n\n  /**\n  * Produce a recursion-safe JSON string.\n  *\n  * This method recurses the specified object to a maximum specified depth\n  * (default 4).\n  *\n  * It also indents sub-objects for debugging output.  The indent level can be\n  * specified, or set to 0 for no indentation.\n  *\n  * This is mostly useful in debugging when the standard JSON.stringify\n  * returns an error.\n  *\n  * @method stringify\n  * @param value {Mixed} Object or value to turn into a JSON string\n  * @param [depth=4] {Integer} Maximum depth to return.  If the depth exceeds\n  *   this value, the string \"[Object]\" is returned as the value.\n  * @param [indent=2] {Integer} Indent the specified number of spaces (0=no indent)\n  * @return {String} A JSON stringified value\n  */\n  Monitor.stringify = function(value, depth, indent) {\n\n    // Defaults\n    indent = typeof(indent) === 'undefined' ? 2 : indent;\n\n    // Return a stringified depth-limited deep copy\n    return JSON.stringify(Monitor.deepCopy(value, depth), null, indent);\n  };\n\n  /**\n  * Expose the stat logger class\n  *\n  * @protected\n  * @method setStatLoggerClass\n  * @param statLoggerClass {Function} Stat logger class to expose\n  */\n  Monitor.setStatLoggerClass = function(StatLoggerClass) {\n\n    // Build the getStatLogger function\n    Monitor.getStatLogger = function(module) {\n      return new StatLoggerClass(module);\n    };\n\n    // Get the logger for the Monitor module\n    stat = Monitor.getStatLogger('Monitor');\n  };\n\n  /**\n  * Expose the logger class\n  *\n  * @protected\n  * @method setLoggerClass\n  * @param loggerClass {Function} Logger class to expose\n  */\n  Monitor.setLoggerClass = function(LoggerClass) {\n\n    // Build the getLogger function\n    Monitor.getLogger = function(module) {\n      return new LoggerClass(module);\n    };\n\n    // Get the logger for the Monitor module\n    log = Monitor.getLogger('Monitor');\n  };\n\n  /**\n  * Constructor for a list of Monitor objects\n  *\n  *     var myList = new Monitor.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Monitor data model objects.\n  * @return {Backbone.Collection} Collection of Monitor data model objects\n  */\n  Monitor.List = Backbone.Collection.extend({model: Monitor});\n\n  // Monitor configurations.  If running in a commonJS environment, load the\n  // configs from the config package.  Otherwise just use the defaults.\n  // See config/default.js for more information on these configurations.\n  var defaultConfig = {\n    appName: 'unknown',\n    serviceBasePort: 42000,\n    portsToScan: 20,\n    allowExternalConnections: false,\n    consoleLogListener: {\n      pattern: \"{trace,warn,error,fatal}.*\"\n    },\n    autoStart: []\n  };\n  if (commonJS) {\n    Monitor.Config = require('config');\n    Monitor.Config.setModuleDefaults('Monitor', defaultConfig);\n  } else {\n    Monitor.Config = {Monitor: defaultConfig};\n  }\n\n  // Expose external dependencies\n  Monitor._ = _;\n  Monitor.Backbone = Backbone;\n  Monitor.Cron = Cron;\n  Monitor.commonJS = commonJS;\n\n  // Export for both commonJS and the browser\n  if (commonJS) {\n    module.exports = Monitor;\n  } else {\n    root.Monitor = Monitor;\n  }\n\n  // Auto-start monitors after loading\n  var autoStart = Monitor.Config.Monitor.autoStart;\n  if (Monitor._.size(autoStart)) {\n    setTimeout(function(){\n      Monitor._.each(autoStart, function(model) {\n        var autoStarted = new Monitor(model);\n        autoStarted.connect(function(error) {\n          if (error) {\n            log.error('autoStart', 'Error auto-starting monitor', model, error);\n          }\n          autoStartedMonitors.push(autoStarted);\n        });\n      });\n    },0);\n  }\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/grunt.js":"// grunt.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For all details and documentation:\n// http://lorenwest.github.com/node-monitor\n\nvar exec = require('child_process').exec;\n\n// This is used in the build automation tasks, and on the server\n// when running in dev mode to serve individual files for debugging.\nvar MODULE_DEF = {\n  lib: [\n    \"lib/Monitor.js\",\n    \"lib/Stat.js\",\n    \"lib/Log.js\",\n    \"lib/Probe.js\",\n    \"lib/Connection.js\",\n    \"lib/Server.js\",\n    \"lib/Router.js\",\n    \"lib/Sync.js\",\n    \"lib/probes/DataModelProbe.js\",\n    \"lib/probes/RecipeProbe.js\",\n    \"lib/probes/PollingProbe.js\",\n    \"lib/probes/StreamProbe.js\",\n    \"lib/probes/InspectProbe.js\",\n    \"lib/probes/StatProbe.js\",\n    \"lib/probes/LogProbe.js\"\n  ],\n  ext: [\n    \"node_modules/underscore/underscore.js\",\n    \"node_modules/backbone/backbone.js\",\n    \"node_modules/backbone-callbacks/backbone-callbacks.js\",\n    \"node_modules/socket.io-client/dist/socket.io.js\"\n  ],\n  probes: [\n    \"lib/probes/FileProbe.js\",\n    \"lib/probes/ReplProbe.js\",\n    \"lib/probes/ProcessProbe.js\",\n    \"lib/probes/SyncProbe.js\",\n    \"lib/probes/FileSyncProbe.js\"\n  ]\n};\n\n// Build automation tasks\nmodule.exports = function(grunt) {\n\n  // Project configuration.\n  grunt.initConfig({\n    pkg: '<json:package.json>',\n    monitor: MODULE_DEF,\n    meta: {\n      banner: '/* <%= pkg.name %> - v<%= pkg.version %> - ' +\n        '<%= grunt.template.today(\"yyyy-mm-dd\") %> */'\n    },\n    lint: {\n      files: ['grunt.js', '<config:monitor.lib>', '<config:monitor.probes>', 'test/*.js']\n    },\n    test: {\n      files: ['test/*.js']\n    },\n    watch: {\n      files: ['grunt.js', 'yuidoc.json', '<config:monitor.lib>', '<config:monitor.probes>', 'config/doc/**', 'test/*.js'],\n      tasks: 'doc lint test'\n    },\n    concat: {\n      lib: {\n        src: ['<banner>', '<config:monitor.lib>'],\n        dest: './dist/monitor.js'\n      },\n      all: {\n        src: ['<banner>', '<config:monitor.ext>', '<config:monitor.lib>'],\n        dest: './dist/monitor-all.js'\n      }\n    },\n    min: {\n      lib: {\n        src: ['<banner>', './dist/monitor.js'],\n        dest: './dist/monitor.min.js'\n\n      },\n      all: {\n        src: ['<banner>', './dist/monitor-all.js'],\n        dest: './dist/monitor-all.min.js'\n      }\n    },\n    jshint: {\n      options: {\n        strict: false,\n        curly: true,\n        eqeqeq: true,\n        immed: true,\n        latedef: true,\n        newcap: true,\n        noarg: true,\n        sub: true,\n        undef: true,\n        boss: true,\n        eqnull: true,\n        node: true\n      },\n      globals: {\n        exports: true\n      }\n    }\n  });\n\n  grunt.registerTask('doc', 'Generate documentation files', function() {\n    var t = this, done = t.async(), child, version = grunt.config.get('pkg').version;\n    var cmd = 'yuidoc --project-version ' + version;\n    console.log(cmd);\n    child = exec(cmd, function (error, stdout, stderr) {\n      console.log(stderr);\n      console.log(stdout);\n      cmd = 'cp -R doc/* ../node-monitor-pages/doc; rm -rf doc';\n      console.log(cmd);\n      child = exec(cmd, function (error, stdout, stderr) {\n        console.log(stderr);\n        console.log(stdout);\n        done();\n      });\n    });\n  });\n\n  grunt.registerTask('rm_dist', 'Remove distribution files', function() {\n    var t = this, done = t.async(), child;\n    child = exec('rm -f dist/*', function (error, stdout, stderr) {\n      console.log(stderr);\n      console.log(stdout);\n      done();\n    });\n  });\n\n  // Default task.\n  grunt.registerTask('default', 'doc lint test dist');\n  grunt.registerTask('dist', 'rm_dist concat:lib concat:all min:lib min:all');\n\n};\n\n// Expose externally\nmodule.exports.MODULE_DEF = MODULE_DEF;\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Stat.js":"/*jslint browser: true */\n// Stat.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('./Monitor'),\n      // Raw events on the server (for speed), backbone events on the browser (for functionality)\n      EventEmitter = Monitor.commonJS ? require('events').EventEmitter.prototype : Monitor.Backbone.Events,\n      _ = Monitor._,\n      emittingNow = false;\n\n\n  /**\n  * A lightweight component for gathering and emitting application statistics\n  *\n  * This is both a collector and emitter for application stats.\n  *\n  * It's designed with low development and runtime cost in mind, encouraging\n  * usage with minimum concern for overhead.\n  *\n  * Stat Collector\n  * --------------\n  *\n  * As a collector, it's a place to send application stats as they're discovered.\n  *\n  * Example for incrementing a stat in your application:\n  *\n  *     var stat = require('monitor').getStatLogger('myModule');\n  *     ...\n  *     stat.increment('requests.inbound');\n  *\n  * The above is a request to increment the ```myModule.requests.inbound``` stat.\n  * It peforms work only if someone is listening for that event.\n  *\n  * Stat Emitter\n  * -------------\n  * As an emitter, Stat is a place to gather stats as they're collected.\n  *\n  * When listening for stats, wildcards can be used to register for many stats\n  * within a group. For example, the following call:\n  *\n  *     var Stat = require('monitor').Stat;\n  *     Stat.on('myModule.*.timer', myFunction);\n  *\n  * Will call ```myFunction``` when all ```myModule.*.timer``` stats are emitted.\n  *\n  * Listeners are invoked with 4 arguments:\n  *\n  * - module - The statLogger module name\n  * - name - The name of the stat that just fired\n  * - value - The numeric value passed\n  * - type - An enumeration of the types of stats:<br/>\n  *   'c'  - Counter.  Add (or subtract) the value to (or from) the prior value<br/>\n  *   'g'  - Gague.  Value is to be recorded as provided<br/>\n  *   'ms' - Timer.  Millisecond amount of time something took.\n  *\n  * <h2 id=\"wildcards\">Wildcards</h2>\n  *\n  * The following wildcards are allowed for registering events.  They're\n  * modeled after the graphite wildcard syntax (from the\n  * <a href=\"https://graphite.readthedocs.org/en/latest/render_api.html#paths-and-wildcards\">graphite docs</a>):\n  *\n  * #### Delimiter\n  * The period (.) character is literal, and matches name segment separators.\n  *\n  * #### Asterisk\n  * The asterisk (*) matches zero or more characters. It is non-greedy, so you\n  * can have more than one within a single path element.\n  *\n  * Example: servers.ix\\*ehssvc\\*v.cpu.total.\\* will return all total CPU metrics\n  * for all servers matching the given name pattern.\n  *\n  * An asterisk at the far right of the pattern matches everything to the right,\n  * including all path segments.  For example, ```servers.*``` matches all\n  * names beginning with ```servers.```.\n  *\n  * #### Character list or range\n  * Characters in square brackets ([...]) specify a single character position in\n  * the path string, and match if the character in that position matches one of\n  * the characters in the list or range.\n  *\n  * A character range is indicated by 2 characters separated by a dash (-), and\n  * means that any character between those 2 characters (inclusive) will match.\n  * More than one range can be included within the square brackets, e.g. foo[a-z0-9]bar\n  * will match foopbar, foo7bar etc..\n  *\n  * If the characters cannot be read as a range, they are treated as a\n  * list - any character in the list will match, e.g. foo[bc]ar will match\n  * foobar and foocar. If you want to include a dash (-) in your list, put\n  * it at the beginning or end, so it's not interpreted as a range.\n  *\n  * #### Value list\n  * Comma-separated values within curly braces ({foo,bar,...}) are treated as\n  * value lists, and match if any of the values matches the current point in\n  * the path. For example, servers.ix01ehssvc04v.cpu.total.{user,system,iowait}\n  * will match the user, system and I/O wait total CPU metrics for the specified\n  * server.\n  *\n  * #### Javascript Regex\n  * For finer grained expression matching, a javascript style regex can be\n  * specified using the ```/.../``` syntax.  This style spans the entire identifier.\n  * You can ignore case using the ```/.../i``` syntax.  If the first character of the\n  * string is a slash, it considers the string a javascript regular expression.\n  *\n  * Choosing Good Names\n  * -------------------\n  * It's a good idea to pick a good naming scheme with each dot-delimited segment\n  * having a consistent, well-defined purpose.  Volatile segments should be as deep\n  * into the hierarchy (furthest right) as possible.  Keeping the names less\n  * volatile makes it easier to turn recording on for all statistics.\n  *\n  * @class Stat\n  * @constructor\n  */\n  var Stat = Monitor.Stat = function(module) {\n    var t = this;\n    t.module = module;\n  };\n  var proto = Stat.prototype;\n\n  // This is a map of registered event names to compiled regexs, for\n  // quickly testing if a statistic needs to be emitted.\n  Stat.eventRegex = {};\n\n  /**\n  * Increment a counter by a specified value\n  *\n  * Assuming someone is listening to this stat, this is an instruction for that\n  * listener to add the specified value (usually 1) to their prior value for this stat.\n  *\n  * This is known as server-side setting, as the server (listener) is responsible\n  * for maintaining the prior and new value for the stat.\n  *\n  * @method increment\n  * @param name {String} Dot.separated name of the counter to increment\n  * @param [value=1] {Number} Amount to increment the counter by.\n  */\n  proto.increment = function(name, value){\n    value = _.isNumber(value) ? value : 1;\n    Stat._emit(this.module, name, value, 'c');\n  };\n\n  /**\n  * Decrement a counter by a specified value\n  *\n  * Assuming someone is listening to this stat, this is an instruction for that\n  * listener to subtract the specified value (usually 1) to their prior value for this stat.\n  *\n  * This is known as server-side setting, as the server (listener) is responsible\n  * for maintaining the prior and new value for the stat.\n  *\n  * @method decrement\n  * @param name {String} Dot.separated name of the counter to decrement\n  * @param [value=1] {Number} Amount to decrement the counter by.\n  */\n  proto.decrement = function(name, value){\n    value = _.isNumber(value) ? value : 1;\n    Stat._emit(this.module, name, value * -1, 'c');\n  };\n\n  /**\n  * Set the stat to the specified value\n  *\n  * This is an instruction to any (all) listener(s) to set the stat to a\n  * specific value.\n  *\n  * This is known as client-side setting, because the client determines the value\n  * of the stat.\n  *\n  * @method gauge\n  * @param name {String} Dot.separated name of the stat\n  * @param value {Number} Number to set the gauge to\n  */\n  proto.gauge = function(name, value){\n    Stat._emit(this.module, name, value, 'g');\n  };\n\n  /**\n  * Record the specified duration (in milliseconds) for the stat\n  *\n  * This is like Stat.gauge() in that it is a client-side setting of a\n  * specified value.  The difference is the scale of the value is specified\n  * as milliseconds.\n  *\n  * This may be one of the most widely used stat methods.  It can (should?) be\n  * used upon callback from asynchronous methods.\n  *\n  * Pattern:\n  *\n  *     var stat = require('monitor').getStatLogger('myModule');\n  *     ...\n  *     var stamp = Date.now();\n  *     SomeAsyncFunction(arg1, function(error) {\n  *       stat.time('SomeAsyncFunction.time', Date.Now() - stamp);\n  *       ...continue with error handling & callback handling\n  *     });\n  *\n  * @method time\n  * @param name {String} Dot.separated name of the stat\n  * @param duration {Integer} Number of milliseconds this stat took to complete\n  */\n  proto.time = function(name, duration){\n    Stat._emit(this.module, name, duration, 'ms');\n  };\n\n  /**\n  * Send the stat to all registered listeners\n  *\n  * @private\n  * @static\n  * @method emit\n  * @param module {String} Module name\n  * @param name {String} Stat name\n  * @param value {Numeric} Stat value\n  * @param type {String} Enumeration.  One of the following:\n  *   'c'  - Counter.  + values increment, - values decrement\n  *   'g'  - Gague.  Statistic is recorded as provided\n  *   'ms' - Timer.  Millisecond amount of time something took\n  */\n  Stat._emit = function(module, name, value, type) {\n    var eventName,\n        fullName;\n\n    // Prevent stat recursion. This has the effect of disabling all stats\n    // for stat handlers (and their downstream effect), but is necessary to\n    // prevent infinite recursion.  If it's desired to stat the output of\n    // stat handlers, then delay that processing until nextTick.\n    if (emittingNow) {\n      return;\n    }\n    emittingNow = true;\n\n    // Test the name against all registered events\n    for (eventName in Stat._events) {\n\n      // Build the full name only if someone is listening\n      if (!fullName) {\n        fullName = module + '.' + name;\n      }\n\n      // Get the regex associated with the name\n      var regex = Stat.eventRegex[eventName];\n      if (!regex) {\n        regex = Stat.eventRegex[eventName] = Stat._buildRegex(eventName);\n      }\n\n      // Test the name with the regex, and emit if it matches\n      if (regex.test(fullName)) {\n        Stat.emit(eventName, module, name, value, type);\n      }\n    }\n\n    // Turn off recursion prevention\n    emittingNow = false;\n  };\n\n  /**\n  * Build a regex from a user entered string following the pattern described\n  * in the class definition.  Loosely:\n  *\n  *    If it looks like a JS regexp, process it as a regexp\n  *    Change all '.' to '\\.'\n  *    Change all '*' to '[^\\.]*' (unless it's at the end, then convert to '.*')\n  *    Change all {one,two} to (one|two)\n  *    Leave all [...] alone - they work as-is\n  *\n  *  If an error occurs, throw an exception\n  *\n  * @private\n  * @static\n  * @method _buildRegex\n  * @param str {String} String to build the regular expression from\n  * @return {RegExp}The regular expression object\n  *\n  */\n  Stat._buildRegex = function(str) {\n    var regexStr = '',\n        modifier = '',\n        lastIdx = str.length - 1,\n        inSquiggly = false;\n\n    // Javascript regular expressions\n    if (/^\\/[^\\/]*\\/i*$/.test(str)) {\n      if (/i$/.test(str)) {\n        modifier = 'i';\n        str = str.replace(/i$/,'');\n      }\n      regexStr = '^' + str.replace(/^\\//,'').replace(/\\/$/,'') + '$';\n    }\n\n    // Process character by character\n    else {\n      for (var i = 0, l = str.length; i < l; i++) {\n        var c = str.substr(i,1);\n        switch (c) {\n          case '.':\n            c = '\\\\.';\n            break;\n          case '*':\n            c = (i === lastIdx ? '.*' : '[^\\\\.]*');\n            break;\n          case '{':\n            c = '(';\n            inSquiggly = true;\n            break;\n          case '}':\n            c = ')';\n            inSquiggly = false;\n            break;\n          case ',':\n            if (inSquiggly) {\n              c = '|';\n            }\n            break;\n        }\n        regexStr += c;\n      }\n\n      // Force it to match the full string\n      regexStr = '^' + regexStr + '$';\n    }\n\n    // Now build the regex.  This throws an exception if poorly formed.\n    return new RegExp(regexStr, modifier);\n  };\n\n  // Mixin event processing for the Stat class\n  _.extend(Stat, EventEmitter);\n\n  // Expose this class from the Monitor module\n  Monitor.setStatLoggerClass(Stat);\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Log.js":"/*jslint browser: true */\n// Log.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('./Monitor'),\n      // Raw events on the server (for speed), backbone events on the browser (for functionality)\n      EventEmitter = Monitor.commonJS ? require('events').EventEmitter.prototype : Monitor.Backbone.Events,\n      Stat = Monitor.Stat,\n      stat = new Stat('Log'),\n      _ = Monitor._,\n      emittingNow = false;\n\n  /**\n  * A lightweight component for gathering and emitting application logs\n  *\n  * It's designed with low development and runtime cost in mind, encouraging\n  * usage with minimum concern for overhead.  Runtime monitoring can be as chatty\n  * as desired, outputting every log statement of every type, or finely tuned\n  * with regular expressions to monitor specific log statements.\n  *\n  * Log Collector\n  * -------------\n  *\n  * As a collector, it's a place to send application logs.\n  *\n  * Example for outputting a log in your application:\n  *\n  *     var log = require('monitor').getLogger('myModule');\n  *     ...\n  *     log.info('Credit limit accepted', limit, requestedAmount);\n  *\n  * The above is a request to output an ```info``` log for ```myModule``` named\n  * ```Credit limit accepted```.  The log entry includes all additional parameters,\n  * in this case the customer credit limit and the reqeusted amount.\n  *\n  * The full name for this log entry is: ```\"info.myModule.Credit limit accepted\"```\n  * The name is important, as monitors can be configured to output logs based\n  * on this name.\n  *\n  * Best practices are to include dynamic parameters in extra arguments\n  * vs. concatenating strings.  This reduces logging overhead, especially\n  * for log statements that aren't currently being watched.\n  *\n  * Log Emitter\n  * -----------\n  * As an emitter, the Log module is a place to capture logging output.\n  *\n  * When listening for log entries, wildcards can be used to register for\n  * particular log types and entries.\n  *\n  *     var Log = require('monitor').Log;\n  *     ...\n  *     Log.on('info.myModule.*', myFunction);\n  *\n  * Will call ```myFunction``` when all ```info.myModule.*``` logs are emitted.\n  *\n  * Listeners are invoked with the following arguments:\n  *\n  * - type - The log type (trace, debug, info, warn, error, or fatal)\n  * - module - The logger module name\n  * - name - The log entry name\n  * - args... - Additional arguments passed into the log entry are passed on\n  *             as additional args to the event listener.\n  *\n  * Wildcards\n  * ---------\n  * A flexible and user-oriented wildcard pattern is used for monitoring\n  * logs.  The pattern is described in the <a href=\"Stat.html#wildcards\">Wildcard secttion of the Stats class</a>.\n  *\n  * Choosing Good Names\n  * -------------------\n  * It's a good idea to pick a good naming scheme with each dot-delimited segment\n  * having a consistent, well-defined purpose.  Volatile segments should be as deep\n  * into the hierarchy (furthest right) as possible.  Keeping the names less\n  * volatile makes it easier to turn statistics recording on for all logs.\n  *\n  * @class Log\n  * @constructor\n  */\n  var Log = Monitor.Log = function(module) {\n    var t = this;\n    t.module = module;\n  };\n  var proto = Log.prototype;\n\n  // This is a map of registered event names to compiled regexs, for\n  // quickly testing if a log needs to be emitted.\n  Log.eventRegex = {};\n\n  /**\n  * Output a ```trace``` log entry\n  *\n  * @method trace\n  * @param name {String} Log entry name\n  * @param [...] {Any} Subsequent arguments to add to the log\n  */\n\n  /**\n  * Output a ```debug``` log entry\n  *\n  * @method debug\n  * @param name {String} Log entry name\n  * @param [...] {Any} Subsequent arguments to add to the log\n  */\n\n  /**\n  * Output a ```info``` log entry\n  *\n  * @method info\n  * @param name {String} Log entry name\n  * @param [...] {Any} Subsequent arguments to add to the log\n  */\n\n  /**\n  * Output a ```warn``` log entry\n  *\n  * @method warn\n  * @param name {String} Log entry name\n  * @param [...] {Any} Subsequent arguments to add to the log\n  */\n\n  /**\n  * Output a ```error``` log entry\n  *\n  * @method error\n  * @param name {String} Log entry name\n  * @param [...] {Any} Subsequent arguments to add to the log\n  */\n\n  /**\n  * Output a ```fatal``` log entry\n  *\n  * @method fatal\n  * @param name {String} Log entry name\n  * @param [...] {Any} Subsequent arguments to add to the log\n  */\n\n  // Add a method for each log type\n  ['trace','debug','info','warn','error','fatal'].forEach(function(method) {\n    proto[method] = function(name) {\n      Log._emit(method, this.module, name, arguments);\n    };\n  });\n\n  /**\n  * Send the log to all registered listeners\n  *\n  * @private\n  * @static\n  * @method emit\n  * @param type {string} The log type (trace, debug, info, etc)\n  * @param module {String} The log module name\n  * @param name {String} The log entry name\n  * @param args {any[]} Arguments to the log entry\n  */\n  Log._emit = function(type, module, name, args) {\n    var eventName,\n        fullName = type + '.' + module + '.' + name;\n\n    // Prevent log recursion. This has the effect of disabling all logging\n    // for log handlers (and their downstream effect), but is necessary to\n    // prevent infinite recursion.  If it's desired to log the output of\n    // log handlers, then delay that processing until nextTick.\n    if (emittingNow) {\n      return;\n    }\n    emittingNow = true;\n\n    // Output a counter stat for this log\n    stat.increment(fullName);\n\n    // Test the name against all registered events\n    for (eventName in Log._events) {\n\n      // Get the regex associated with the name (using the Stat package)\n      var regex = Log.eventRegex[eventName];\n      if (!regex) {\n        regex = Log.eventRegex[eventName] = Stat._buildRegex(eventName);\n      }\n\n      // Test the long name with the regex, and emit if it matches\n      if (regex.test(fullName)) {\n\n        // Build the arguments as event name, log type, module, name, [other args...]\n        var allArgs = _.toArray(args),\n            emitFn = Log.emit || Log.trigger; // NodeJS/server=emit, Backbone/browser=trigger\n        allArgs.splice(0, 1, eventName, type, module, name);\n        emitFn.apply(Log, allArgs);\n      }\n    }\n\n    // Turn off recursion prevention\n    emittingNow = false;\n  };\n\n  // Mixin event processing for the Log class\n  _.extend(Log, EventEmitter);\n\n  // Expose this class from the Monitor module\n  Monitor.setLoggerClass(Log);\n\n  /**\n  * Output log statements to the console\n  *\n  * This method can be used as a listener to send logs to the console.\n  *\n  * It uses console.error() for error and fatal log types, and console.log()\n  * for all other log types.\n  *\n  * Example:\n  *\n  *     var Log = Monitor.Log;\n  *     Log.on('*.MyModule.*', Log.console);\n  *\n  * @static\n  * @method consoleLogger\n  * @param type {string} The log type (trace, debug, info, etc)\n  * @param module {String} The log module name\n  * @param name {String} The log entry name\n  * @param args {any...} All original, starting with the short name\n  */\n  Log.console = function(type, module, name) {\n\n    // Build the string to log, in log4js format\n    var nowStr = (new Date()).toJSON(),\n        args = _.toArray(arguments),\n        logStr = '[' + nowStr + '] [' + type.toUpperCase() + '] ' + module;\n\n    // Remove the type, module, name leaving the args to the log\n    args.splice(0,3);\n\n    // If no args, then they didn't provide a name\n    if (args.length === 0) {\n      args = [name];\n    }\n    else {\n      // Add the log entry name\n      logStr += '.' + name;\n    }\n\n    // If the output is simple, just print it.  Otherwise JSON.stringify it.\n    logStr += ' - ';\n    if (args.length === 1 && typeof args[0] === 'string') {\n      logStr += args[0];\n    }\n    else {\n      try {\n        logStr += JSON.stringify(args);\n      } catch(e) {\n        logStr += Monitor.stringify(args);\n      }\n    }\n\n    // Send to the console - Log or error\n    if (type === 'error' || type === 'fatal') {\n      console.error(logStr);\n    }\n    else {\n      console.log(logStr);\n    }\n\n  };\n\n  // Attach the console log listener\n  var pattern = Monitor.Config.Monitor.consoleLogListener.pattern;\n  if (pattern) {\n    Log.on(pattern, Log.console);\n  }\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Probe.js":"// Probe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('./Monitor'),\n      log = Monitor.getLogger('Probe'),\n      stat = Monitor.getStatLogger('Probe'),\n      Cron = Monitor.Cron, _ = Monitor._, Backbone = Monitor.Backbone;\n\n  /**\n  * A software device used to expose real time data to monitors\n  *\n  * This is the base class from which all probe implementations extend.\n  *\n  * In order to send probe data to monitors, probe implementations simply set\n  * their model data using ```set()```.  Those changes are detected and propagated\n  * to all monitors of this probe, firing their change events.\n  *\n  * In order to allow remote probe control, probes need only provide a method\n  * called ```{name}_control()```.  See the ```ping_control()``` method as an example,\n  * and the ```Probe.onControl()``` method for more information.\n  *\n  * @class Probe\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param model.id {String} The probe id.\n  *       Assigned by the <a href=\"Router.html\">Router</a> on probe instantiation.\n  */\n  var Probe = Monitor.Probe = Backbone.Model.extend({\n\n    defaults: {\n      id:  null\n    },\n\n    /**\n    * Initialize the probe\n    *\n    * This is called on the probe during construction.  It contains\n    * the probe initialization attributes and an option to make probe\n    * construction asynchronous.\n    *\n    * Probe implementations can defer the initial response to the monitor until\n    * the initial state is loaded.  This allows the callback on\n    * <a href=\"Monitor.html#method_connect\">```Monitor.connect()```</a>\n    * to have the complete initial state of the probe when called.\n    *\n    * If the initial probe state cannot be determined in ```initialize```, it should\n    * set the ```options.asyncInit``` option to ```true```, and call the\n    * ```options.callback(error)``` once the initial state is determined.\n    *\n    *     // Asynchronous initialization\n    *     options.asyncInit = true;\n    *     var callback = options.callback\n    *\n    * If ```asyncInit``` is set to true, the ```callback``` must be called once\n    * the initial state of the probe is known (or in an error condition).\n    *\n    *     // Set the initial state, and call the callback\n    *     this.set(...);\n    *     callback(null);\n    *\n    * See the <a href=\"../files/lib_probes_FileProbe.js.html#l47\">```initialize```</a>\n    * method of the <a href=\"FileProbe.html\">FileProbe</a> probe for an example.  It defers\n    * returning the probe to the monitor until the initial file contents are loaded.\n    *\n    * @method initialize\n    * @param attributes {Object} Initial probe attributes sent in from the Monitor\n    * @param options {Object} Initialization options\n    *     @param options.asyncInit {boolean} Set this to TRUE if the initial probe\n    *         state can't be known immediately.\n    *     @param options.callback {function(error)} The callback to call\n    *         if asyncInit is set to true.  If an error is passed, the probe\n    *         will not be used.\n    */\n    initialize: function(attributes, options) {\n      var t = this;\n      log.info('init', t.toJSON(), options);\n    },\n\n    /**\n    * Release any resources consumed by this probe.\n    *\n    * This can be implemented by derived classes that need to be informed when\n    * they are to be shut down.\n    *\n    * Probes that listen to events should use this method to remove their\n    * event listeners.\n    *\n    * @method release\n    */\n    release: function(){\n      var t = this;\n      log.info('release', t.toJSON());\n    },\n\n    /**\n    * Dispatch a control message to the appropriate control function.\n    *\n    * This is called when the\n    * <a href=\"Monitor.html#method_control\">```control()```</a>\n    * method of a monitor is called.\n    * The name determines the method name called on the probe.\n    *\n    * The probe must implement a method with the name ```{name}_control()```,\n    * and that method must accept two parameters - an input params and a callback.\n    * The callback must be called, passing an optional error and response object.\n    *\n    * For example, if the probe supports a control with the name ```go```, then\n    * all it needs to do is implement the ```go_control()``` method with the\n    * proper signature.  See ```ping_control()``` for an example.\n    *\n    * @method onControl\n    * @param name {String} Name of the control message.\n    * @param [params] {Any} Input parameters specific to the control message.\n    * @param [callback] {Function(error, response)} Called to send the message (or error) response.\n    * <ul>\n    *   <li>error (Any) An object describing an error (null if no errors)</li>\n    *   <li>response (Any) Response parameters specific to the control message.\n    * </ul>\n    */\n    onControl: function(name, params, callback) {\n      var t = this,\n          controlFn = t[name + '_control'],\n          startTime = Date.now(),\n          errMsg,\n          logId = 'onControl.' + t.probeClass + '.' + name;\n\n      params = params || {};\n      callback = callback || function(){};\n      log.info(logId, t.get('id'), params);\n\n      if (!controlFn) {\n        errMsg = 'No control function: ' + name;\n        log.error(logId, errMsg);\n        return callback({msg: errMsg});\n      }\n\n      var whenDone = function(error) {\n        if (error) {\n          log.error(logId + '.whenDone', error);\n          return callback(error);\n        }\n        var duration = Date.now() - startTime;\n        log.info(logId, params);\n        stat.time(t.logId, duration);\n        callback.apply(null, arguments);\n      };\n\n      // Run the control on next tick.  This provides a consistent callback\n      // chain for local and remote probes.\n      setTimeout(function(){\n        try {\n          controlFn.call(t, params, whenDone);\n        } catch (e) {\n          errMsg = 'Error calling control: ' + t.probeClass + ':' + name;\n          whenDone({msg:errMsg, err: e.toString()});\n        }\n      }, 0);\n    },\n\n    /**\n    * Remotely set a probe attribute.\n    *\n    * This allows setting probe attributes that are listed in writableAttributes.\n    * It can be overwritten in derived Probe classes for greater control.\n    *\n    * @method set_control\n    * @param attrs {Object} Name/Value attributes to set.  All must be writable.\n    * @param callback {Function(error)} Called when the attributes are set or error\n    */\n    set_control: function(attrs, callback) {\n      var t = this,\n          writableAttributes = t.get('writableAttributes') || [];\n\n      // Validate the attributes are writable\n      if (writableAttributes !== '*') {\n        for (var attrName in attrs) {\n          if (writableAttributes.indexOf(attrName) < 0) {\n            return callback({code:'NOT_WRITABLE', msg: 'Attribute not writable: ' + attrName});\n          }\n        }\n      }\n\n      // Set the data\n      var error = null;\n      if (!t.set(attrs)) {\n        error = {code:'VALIDATION_ERROR', msg:'Data set failed validation'};\n        log.warn('set_control', error);\n      }\n      return callback(error);\n    },\n\n    /**\n    * Respond to a ping control sent from a monitor\n    *\n    * @method ping_control\n    * @param params {Object} Input parameters (not used)\n    * @param callback {Function(error, response)} Called to send the message (or error) response.\n    * <ul>\n    *   <li>error (Any) An object describing an error</li>\n    *   <li>response (String) The string 'pong' is returned as the response</li>\n    * </ul>\n    */\n    ping_control: function(params, callback) {\n      return callback(null, 'pong');\n    }\n\n  });\n\n  // Register probe classes when loaded\n  Probe.classes = {}; // key = name, data = class definition\n  Probe.extend = function(params) {\n    var t = this, probeClass = Backbone.Model.extend.apply(t, arguments);\n    if (params.probeClass) {Probe.classes[params.probeClass] = probeClass;}\n    return probeClass;\n  };\n\n  /**\n  * Constructor for a list of Probe objects\n  *\n  *     var myList = new Probe.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Probe data model objects.\n  * @return {Backbone.Collection} Collection of Probe data model objects\n  */\n  Probe.List = Backbone.Collection.extend({model: Probe});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Connection.js":"// Connection.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('./Monitor'),\n      Cron = Monitor.Cron, _ = Monitor._, Backbone = Monitor.Backbone,\n      log = Monitor.getLogger('Connection'),\n      stat = Monitor.getStatLogger('Connection'),\n      Config = Monitor.Config, SocketIO = root.io || require('socket.io-client'),\n      Probe = Monitor.Probe,\n      nextConnectionNum = 1;\n\n  /**\n  * Core monitor classes\n  *\n  * Classes in this module represent baseline monitor functionality.  They can\n  * be loaded and run in a node.js container as well as within a browser.\n  *\n  * @module Monitor\n  */\n\n  /**\n  * Connection with a remote process\n  *\n  * Instances of this class represent a connection with a remote monitor\n  * process.  The remote process is a peer of this process - it may produce\n  * and/or consume probe information.\n  *\n  * This is an internal class created when a connection to a server is\n  * requested from a monitor, or when an external connection is made from\n  * a <a href=\"Server.html\">Server</a> instance.\n  *\n  * @class Connection\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *   @param [model.hostName] {String} The host name to connect with. Used if url isn't present.\n  *   @param [model.hostPort] {Number} The host port to connect using. Used if url isn't present.\n  *   @param [model.url] {String} The URL used to connect. Built if hostName is supplied.\n  *   @param [model.socket] {io.socket} Use this pre-connected socket instead of creating a new one.\n  *   @param [model.gateway=false] {Boolean} Allow this connection to use me as a gateway?  See <code><a href=\"Router.html#method_setGateway\">Router.setGateway()</a></code>\n  *   @param [model.firewall=false] {Boolean} Firewall inbound probe requests on this connection?\n  *   @param [model.remoteHostName] {String READONLY} Host name given by the remote server.\n  *   @param [model.remoteAppName] {String READONLY} App name given by the remote server.\n  *   @param [model.remoteAppInstance] {Integer READONLY} The remote application instance ID running on the host.\n  *   @param [model.remotePID] {String READONLY} Remote process ID.\n  *   @param [model.remoteProbeClasses] {Array of String READONLY} Array of probe classes available to the remote server.\n  *   @param [model.remoteGateway] {Boolean READONLY} Can the remote process act as a gateway?\n  *   @param [model.remoteFirewall] {Boolean READONLY} Is the remote side firewalled from inbound probe requests?\n  */\n\n  /**\n  * Connected to remote monitor process\n  *\n  * This event is emitted after the two sides of the connection have exchanged\n  * information about themselves.\n  *\n  * @event connect\n  */\n  var Connection = Monitor.Connection = Backbone.Model.extend({\n\n    defaults:  {\n      hostName: '',\n      hostPort: null,\n      url: null,\n      socket: null,\n      gateway: false,\n      firewall: false,\n      remoteHostName: null,\n      remoteAppName: null,\n      remoteAppInstance: 0,\n      remotePID: 0,\n      remoteProbeClasses: [],\n      remoteGateway: false,\n      remoteFirewall: false\n    },\n\n    initialize: function(params) {\n      var t = this;\n      t.connecting = true;          // Currently connecting?\n      t.connected = false;          // Currently connected?\n      t.socketEvents = null;        // Key = event name, data = handler function\n      t.remoteProbeIdsByKey = {};   // Key = probeKey, data = probeId\n      t.remoteProbesById = {};      // Key = probeId, data = {Probe proxy}\n      t.incomingMonitorsById = {};  // Key = probeId, data = {Monitor proxy}\n\n      // Create a connection ID for logging\n      t.logId = (nextConnectionNum++) + '.';\n\n      // Either connect to an URL or with an existing socket\n      if (params.socket) {\n        t.bindConnectionEvents();\n        log.info(t.logId + 'connect', {socketId:params.socket.id});\n      }\n      else if (params.url || (params.hostName && params.hostPort)) {\n        t.connect();\n        log.info(t.logId + 'connect', {url:t.get('url')});\n      }\n      else {\n        log.error('init', 'Connection must supply a socket, url, or host name/port');\n      }\n    },\n\n    // Initiate a connection with a remote server\n    connect: function() {\n      var t = this, hostName = t.get('hostName'), hostPort = t.get('hostPort'),\n      url = t.get('url');\n\n      // Build the URL if not specified\n      if (!url) {\n        url = t.attributes.url = 'http://' + hostName + ':' + hostPort;\n        t.set('url', url);\n      }\n\n      // Connect with this url\n      var opts = {\n        // 'transports': ['websocket', 'xhr-polling', 'jsonp-polling'],\n        'force new connection': true,      // Don't re-use existing connections\n        'reconnect': false                 // Don't let socket.io reconnect.\n                                           // Reconnects are performed by the Router.\n      };\n      var socket = SocketIO.connect(url, opts);\n      t.set({socket:socket}).bindConnectionEvents();\n    },\n\n    /**\n    * Ping a remote connection\n    *\n    * @method ping\n    * @param callback {Function(error)} Callback when response is returned\n    */\n    ping: function(callback) {\n      var t = this;\n      callback = callback || function(){};\n      var onPong = function() {\n        t.off('pong', onPong);\n        callback();\n      };\n      t.on('pong', onPong);\n      t.emit('connection:ping');\n    },\n\n    /**\n    * Disconnect from the remote process\n    *\n    * This can be called from the underlying transport if it detects a disconnect,\n    * or it can be manually called to force a disconnect.\n    *\n    * @method disconnect\n    * @param reason {String} Reason for the disconnect\n    */\n    /**\n    * <strong>Disconnected from a remote monitor process</strong>\n    *\n    * This event is emitted after the remote connection is disconnected and\n    * resources released.\n    *\n    * @event disconnect\n    * @param reason {String} Reason for the disconnect\n    */\n    disconnect: function(reason) {\n      var t = this, socket = t.get('socket');\n      t.connecting = false;\n      t.connected = false;\n\n      // Only disconnect once.\n      // This method can be called many times during a disconnect (manually,\n      // by socketIO disconnect, and/or by the underlying socket disconnect).\n      if (t.socketEvents) {\n        t.removeAllEvents();\n        socket.disconnect();\n        t.trigger('disconnect', reason);\n        log.info(t.logId + 'disconnect', reason);\n      }\n    },\n\n    /**\n    * Is this connection with the specified host?\n    *\n    * @method isThisHost\n    * @protected\n    * @param hostName {String} The host name to check\n    * @return withHost {Boolean} True if the connection is with this host\n    */\n    isThisHost: function(hostName) {\n      var t = this, testHost = hostName.toLowerCase(),\n          myHostName = t.get('hostName'), remoteHostName = t.get('remoteHostName');\n      myHostName = myHostName && myHostName.toLowerCase();\n      remoteHostName = remoteHostName && remoteHostName.toLowerCase();\n      return (testHost === myHostName || testHost ===  remoteHostName);\n    },\n\n    /**\n    * Emit the specified message to the socket.\n    *\n    * The other side of the connection can handle and respond to the message\n    * using the 'on' method.\n    *\n    * @method emit\n    * @protected\n    * @param name {String} The message name to send\n    * @param args... {Mixed} Variable number of arguments to send with the message\n    * @param callback {Function} Called when remote sends a reply\n    */\n    emit: function() {\n      var t = this, socket = t.get('socket');\n      log.info(t.logId + 'emit', Monitor.deepCopy(arguments, 5));\n      socket.emit.apply(socket, arguments);\n    },\n\n    /**\n    * Bind the specified handler to the remote socket message.\n    *\n    * Only a single handler (per message name) can be bound using this method.\n    *\n    * @method addEvent\n    * @protected\n    * @param eventName {String} The event name to handle\n    * @param handler {Function (args..., callback)} Called when the message is received.\n    * <ul>\n    *   <li>args... {Mixed} Arguments sent in by the remote client</li>\n    *   <li>callback {Function} Final arg if the client specified a callback</li>\n    * </ul>\n    */\n    addEvent: function(eventName, handler) {\n      var t = this, socket = t.get('socket');\n      t.socketEvents = t.socketEvents || {};\n      if (t.socketEvents[eventName]) {\n        throw new Error('Event already connected: ' + eventName);\n      }\n      socket.on(eventName, handler);\n      t.socketEvents[eventName] = handler;\n      return t;\n    },\n\n    // Remove the specified event from the socket\n    removeEvent: function(eventName) {\n      var t = this, socket = t.get('socket');\n      if (t.socketEvents && t.socketEvents[eventName]) {\n        socket.removeListener(eventName, t.socketEvents[eventName]);\n        delete t.socketEvents[eventName];\n      }\n      return t;\n    },\n\n    // Remove all events bound to the socket\n    removeAllEvents: function() {\n      var t = this, socket = t.get('socket');\n      for (var event in t.socketEvents) {\n        socket.removeListener(event, t.socketEvents[event]);\n      }\n      t.socketEvents = null;\n      return t;\n    },\n\n    /**\n    * An error has occurred on the connection\n    *\n    * This event is triggered when an error occurs on the connection.  Errors\n    * may occur when network is unstable, and can be an indication of impending\n    * disconnection.\n    *\n    * @event error\n    * @param err {Object} Reason for the error (from underlying transport)\n    */\n    bindConnectionEvents: function() {\n      var t = this, socket = t.get('socket');\n      if (t.socketEvents) {throw new Error('Already connected');}\n      t.socketEvents = {};  // key = event name, data = handler\n\n      // Failure events\n      t.addEvent('connect_failed', function(){\n        t.trigger('error', 'connect failed');\n        t.disconnect('connect failed');\n      });\n      t.addEvent('disconnect', function(){t.disconnect('remote_disconnect');});\n      t.addEvent('error', function(reason){\n        t.trigger('error', reason);\n        t.disconnect('connect error');\n      });\n\n      // Inbound probe events\n      t.addEvent('probe:connect', t.probeConnect.bind(t));\n      t.addEvent('probe:disconnect', t.probeDisconnect.bind(t));\n      t.addEvent('probe:control', t.probeControl.bind(t));\n\n      // Connection events\n      t.addEvent('connection:ping', function(){socket.emit('connection:pong');});\n      t.addEvent('connection:pong', function(){t.trigger('pong');});\n\n      // Connected once remote info is known\n      t.addEvent('connection:info', function (info) {\n        t.set({\n          remoteHostName: info.hostName,\n          remoteAppName: info.appName,\n          remoteAppInstance: info.appInstance,\n          remotePID: info.pid,\n          remoteProbeClasses: info.probeClasses,\n          remoteGateway: info.gateway,\n          remoteFirewall: info.firewall\n        });\n        t.connecting = false;\n        t.connected = true;\n        t.trigger('connect');\n      });\n\n      // Determine the process id\n      var pid = typeof process === 'undefined' ? 1 : process.pid;\n\n      // Determine the app instance\n      var appInstance = '' + (typeof process === 'undefined' ? pid : process.env.NODE_APP_INSTANCE || pid);\n\n      // Exchange connection information\n      socket.emit('connection:info', {\n        hostName:Monitor.getRouter().getHostName(),\n        appName:Config.Monitor.appName,\n        appInstance: appInstance,\n        pid: pid,\n        probeClasses: _.keys(Probe.classes),\n        gateway:t.get('gateway'),\n        firewall:t.get('firewall')\n      });\n    },\n\n    /**\n    * Process an inbound request to connect with a probe\n    *\n    * This will fail if this connection was created as a firewall.\n    *\n    * @method probeConnect\n    * @protected\n    * @param monitorJSON {Object} Probe connection parameters, including:\n    *     @param monitorJSON.probeClass {String} The probe class\n    *     @param monitorJSON.initParams {Object} Probe initialization parameters\n    *     @param monitorJSON.hostName {String} Connect with this host (if called as a gateway)\n    *     @param monitorJSON.appName {String} Connect with this app (if called as a gateway)\n    * @param callback {Function(error, probeJSON)} Callback function\n    */\n    probeConnect: function(monitorJSON, callback) {\n      callback = callback || function(){};\n      var t = this,\n          errorText = '',\n          router = Monitor.getRouter(),\n          gateway = t.get('gateway'),\n          startTime = Date.now(),\n          firewall = t.get('firewall'),\n          logCtxt = _.extend({}, monitorJSON);\n\n      // Don't allow inbound requests if this connection is firewalled\n      if (firewall) {\n        errorText = 'firewalled';\n        log.error('probeConnect', errorText, logCtxt);\n        return callback(errorText);\n      }\n\n      // Determine the connection to use (or internal)\n      router.determineConnection(monitorJSON, gateway, function(err, connection) {\n        if (err) {return callback(err);}\n        if (connection && !gateway) {return callback('Not a gateway');}\n\n        // Function to run upon connection (internal or external)\n        var onConnect = function(error, probe) {\n\n          if (error) {\n            log.error(t.logId + 'probeConnect', error, logCtxt);\n            return callback(error);\n          }\n\n          // Get probe info\n          var probeId = probe.get('id');\n          logCtxt.id = probeId;\n\n          // Check for a duplicate proxy for this probeId.  This happens when\n          // two connect requests are made before the first one completes.\n          var monitorProxy = t.incomingMonitorsById[probeId];\n          if (monitorProxy != null) {\n            probe.refCount--;\n            logCtxt.dupDetected = true;\n            logCtxt.refCount = probe.refCount;\n            log.info(t.logId + 'probeConnected', logCtxt);\n            return callback(null, monitorProxy.probe.toJSON());\n          }\n\n          // Connect the montior proxy\n          monitorProxy = new Monitor(monitorJSON);\n          monitorProxy.set('probeId', probeId);\n          t.incomingMonitorsById[probeId] = monitorProxy;\n          monitorProxy.probe = probe;\n          monitorProxy.probeChange = function(){\n            try {\n              t.emit('probe:change:' + probeId, probe.changedAttributes());\n            }\n            catch (e) {\n              log.error('probeChange', e, probe, logCtxt);\n            }\n          };\n          probe.connectTime = Date.now();\n          var duration = probe.connectTime - startTime;\n          logCtxt.duration = duration;\n          logCtxt.refCount = probe.refCount;\n          log.info(t.logId + 'probeConnected', logCtxt);\n          stat.time(t.logId + 'probeConnected', duration);\n          callback(null, probe.toJSON());\n          probe.on('change', monitorProxy.probeChange);\n\n          // Disconnect the probe on connection disconnect\n          t.on('disconnect', function() {\n            t.probeDisconnect({probeId:probeId});\n          });\n        };\n\n        // Connect internally or externally\n        if (connection) {\n          router.connectExternal(monitorJSON, connection, onConnect);\n        } else {\n          router.connectInternal(monitorJSON, onConnect);\n        }\n      });\n    },\n\n    /**\n    * Process an inbound request to disconnect with a probe\n    *\n    * @method probeDisconnect\n    * @protected\n    * @param params {Object} Disconnect parameters, including:\n    *   probeId {String} The unique probe id\n    * @param callback {Function(error)} Callback function\n    */\n    probeDisconnect: function(params, callback) {\n      callback = callback || function(){};\n      var t = this,\n          errorText = '',\n          router = Monitor.getRouter(),\n          probeId = params.probeId,\n          monitorProxy = t.incomingMonitorsById[probeId],\n          firewall = t.get('firewall'),\n          logCtxt = null,\n          probe = null;\n\n      // Already disconnected\n      if (!monitorProxy || !monitorProxy.probe) {\n        return callback(null);\n      }\n\n      // Get a good logging context\n      probe = monitorProxy.probe;\n      logCtxt = {\n        probeClass: monitorProxy.get('probeClass'),\n        initParams: monitorProxy.get('initParams'),\n        probeId: probeId\n      };\n\n      // Called upon disconnect (internal or external)\n      var onDisconnect = function(error) {\n        if (error) {\n          log.error(t.logId + 'probeDisconnect', error);\n          return callback(error);\n        }\n        var duration = logCtxt.duration = Date.now() - probe.connectTime;\n        probe.off('change', monitorProxy.probeChange);\n        monitorProxy.probe = monitorProxy.probeChange = null;\n        delete t.incomingMonitorsById[probeId];\n        log.info(t.logId + 'probeDisconnected', logCtxt);\n        stat.time(t.logId + 'probeDisconnected', duration);\n        return callback(null);\n      };\n\n      // Disconnect from an internal or external probe\n      if (probe && probe.connection) {\n        router.disconnectExternal(probe.connection, probeId, onDisconnect);\n      } else {\n        router.disconnectInternal(probeId, onDisconnect);\n      }\n    },\n\n    /**\n    * Process an inbound control request to a probe\n    *\n    * @method probeControl\n    * @protected\n    * @param params {Object} Control parameters, including:\n    *   probeId {String} The unique probe id\n    *   name {String} The control message name\n    *   params {Object} Any control message parameters\n    * @param callback {Function(error, returnParams)} Callback function\n    */\n    probeControl: function(params, callback) {\n      callback = callback || function(){};\n      var t = this,\n          errorText = '',\n          logId = t.logId + 'probeControl',\n          startTime = Date.now(),\n          router = Monitor.getRouter(),\n          firewall = t.get('firewall');\n\n      // Don't allow inbound requests if this connection is firewalled\n      if (firewall) {\n        errorText = 'firewalled';\n        log.error(logId, errorText);\n        return callback(errorText);\n      }\n\n      // Called upon return\n      var onReturn = function(error) {\n        if (error) {\n          log.error(logId, error);\n          return callback(error);\n        }\n        else {\n          var duration = Date.now() - startTime;\n          log.info(logId + '.return', {duration:duration, returnArgs: arguments});\n          stat.time(logId, duration);\n          return callback.apply(null, arguments);\n        }\n      };\n\n      // Is this an internal probe?\n      var probe = router.runningProbesById[params.probeId];\n      if (!probe) {\n\n        // Is this a remote (proxied) probe?\n        var monitorProxy = t.incomingMonitorsById[params.probeId];\n        if (!monitorProxy) {\n          errorText = 'Probe id not found: ' + params.probeId;\n          log.error(errorText);\n          return callback(errorText);\n        }\n\n        // Proxying requires this form vs. callback as last arg.\n        return monitorProxy.control(params.name, params.params, function(err, returnParams) {\n          onReturn(err, returnParams);\n        });\n      }\n      logId = logId + '.' + probe.probeClass + '.' + params.name;\n      log.info(logId + '.request', {params:params.params, probeId:params.probeId});\n      return probe.onControl(params.name, params.params, onReturn);\n    }\n\n  });\n\n  /**\n  * Constructor for a list of Connection objects\n  *\n  *     var myList = new Connection.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Connection data model objects.\n  * @return {Backbone.Collection} Collection of Connection data model objects\n  */\n  Connection.List = Backbone.Collection.extend({model: Connection});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Server.js":"// Server.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('./Monitor'),\n      Config = Monitor.Config, _ = Monitor._, Backbone = Monitor.Backbone,\n      log = Monitor.getLogger('Server'),\n      stat = Monitor.getStatLogger('Server'),\n      Connection = Monitor.Connection,\n      Http = Monitor.commonJS ? require('http') : null,\n      SocketIO = root.io || require('socket.io');\n\n  /**\n  * A server for accepting inbound connections from remote monitors\n  *\n  * Servers are created when a process wants to expose probe data to remote\n  * monitors.  Example:\n  *\n  *     // Accept remote monitors\n  *     var server = new Monitor.Server();\n  *     server.start();\n  *\n  * An instance of this class represents a listening server accepting inbound\n  * connections.  As inbound connections are detected, a new\n  * <a href=\"Connection.html\">Connection</a> object is created to manage\n  * traffic on that connection.\n  *\n  * Security:  Make sure the port range specified in Monitor.Config (starting\n  * at 42000) is not exposed outside your internal network.  If you desire a\n  * different security model, create your secure server and pass it to the\n  * constructor.\n  *\n  * @class Server\n  * @extends Backbone.Model\n  * @constructor\n  * @param model - Initial data model.  Can be a JS object or another Model.\n  *     @param model.gateway {Boolean} - Allow incoming monitors to use me as a gateway (default false)\n  *     @param model.server {HttpServer} - The listening node.js server.  Constructed by this class, or specified if a custom server is desired.\n  *     @param model.port {Integer} - The connected port.  This is set upon start() if the server isn't specified on construction.\n  */\n  var Server = Monitor.Server = Backbone.Model.extend({\n\n    initialize: function(params) {\n      var t = this;\n      t.isListening = false;\n      t.connections = new Connection.List();\n    },\n\n    /**\n    * Start accepting monitor connections\n    *\n    * This method starts listening for incoming monitor connections on the\n    * server.\n    *\n    * If the server was specified during object creation, this binds the\n    * socket.io service to the server.\n    *\n    * If the server was not specified during object creation, this will create\n    * a server on the first available monitor port.\n    *\n    * @method start\n    * @param options {Object} - Start options. OPTIONAL\n    *     @param options.port {Integer} - Port to attempt listening on if server isn't specified.  Default: 42000\n    *     @param options.attempt {Integer} - Attempt number for internal recursion detection.  Default: 1\n    * @param callback {Function(error)} - Called when the server is accepting connections.\n    */\n    /**\n    * The server has started\n    *\n    * This event is fired when the server has determined the port to accept\n    * connections on, and has successfully configured the server to start\n    * accepting new monitor connections.\n    *\n    * @event start\n    */\n    /**\n    * A client error has been detected\n    *\n    * This event is fired if an error has been detected in the underlying\n    * transport.  It may indicate message loss, and may result in a\n    * subsequent stop event if the connection cannot be restored.\n    *\n    * @event error\n    */\n    start: function(options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = null;\n      }\n      options = options || {};\n      callback = callback || function(){};\n      var t = this, server = t.get('server'), error,\n          startTime = Date.now(),\n          port = options.port || Config.Monitor.serviceBasePort,\n          attempt = options.attempt || 1,\n          allowExternalConnections = Config.Monitor.allowExternalConnections;\n\n      // Recursion detection.  Only scan for so many ports\n      if (attempt > Config.Monitor.portsToScan) {\n        error = {err:'connect:failure', msg: 'no ports available'};\n        log.error('start', error);\n        return callback(error);\n      }\n\n      // Bind to an existing server, or create a new server\n      if (server) {\n        t.bindEvents(callback);\n      } else {\n        server = Http.createServer();\n\n        // Try next port if a server is listening on this port\n        server.on('error', function(err) {\n          if (err.code === 'EADDRINUSE') {\n            // Error if the requested port is in use\n            if (t.get('port')) {\n              log.error('portInUse',{host:host, port:port});\n              return callback({err:'portInUse'});\n            }\n            // Try the next port\n            log.info('portInUse',{host:host, port:port});\n            return t.start({port:port + 1, attempt:attempt + 1}, callback);\n          }\n          // Unknown error\n          callback(err);\n        });\n\n        // Allow connections from INADDR_ANY or LOCALHOST only\n        var host = allowExternalConnections ? '0.0.0.0' : '127.0.0.1';\n\n        // Start listening, callback on success\n        server.listen(port, host, function(){\n\n          // Set a default NODE_APP_INSTANCE based on the available server port\n          if (!process.env.NODE_APP_INSTANCE)  {\n            process.env.NODE_APP_INSTANCE = '' + (port - Config.Monitor.serviceBasePort + 1);\n          }\n\n          // Record the server & port, and bind incoming events\n          t.set({server: server, port: port});\n          t.bindEvents(callback);\n          log.info('listening', {\n            appName: Config.Monitor.appName,\n            NODE_APP_INSTANCE: process.env.NODE_APP_INSTANCE,\n            listeningOn: host,\n            port: port\n          });\n        });\n      }\n    },\n\n    /**\n    * Bind incoming socket events to the server\n    *\n    * This method binds to the socket events and attaches the socket.io\n    * server.  It is called when the connection starts listening.\n    *\n    * @protected\n    * @method bindEvents\n    * @param callback {Function(error)} - Called when all events are bound\n    */\n    bindEvents: function(callback) {\n\n      // Detect server errors\n      var t = this, server = t.get('server');\n      server.on('clientError', function(err){\n        log.error('bindEvents', 'clientError detected on server', err);\n        t.trigger('error', err);\n      });\n      server.on('close', function(err){\n        server.hasEmittedClose = true;\n        log.info('bindEvents.serverClose', 'Server has closed', err);\n        t.stop();\n      });\n\n      // Start up the socket.io server.\n      var socketIoParams = {\n        log: false\n      };\n      t.socketServer = SocketIO.listen(server, socketIoParams);\n      t.socketServer.sockets.on('connection', function (socket) {\n        var connection = Monitor.getRouter().addConnection({\n          socket: socket, gateway: t.get('gateway')\n        });\n        t.connections.add(connection);\n        var onDisconnect = function(reason) {\n          t.connections.remove(connection);\n          Monitor.getRouter().removeConnection(connection);\n          connection.off('disconnect', onDisconnect);\n          log.info('client.disconnect', 'Disconnected client socket');\n        };\n        connection.on('disconnect', onDisconnect);\n        log.info('client.connect', 'Connected client socket');\n      });\n\n      // Notify that we've started\n      t.isListening = true;\n      if (callback) {callback(null);}\n      t.trigger('start');\n    },\n\n    /**\n    * Stop processing inbound monitor traffic\n    *\n    * This method stops accepting new inbound monitor connections, and closes\n    * all existing monitor connections associated with the server.\n    *\n    * @method stop\n    * @param callback {Function(error)} - Called when the server has stopped\n    */\n    /**\n    * The server has stopped\n    *\n    * This event is fired after the server has stopped accepting inbound\n    * connections, and has closed all existing connections and released\n    * associated resources.\n    *\n    * @event stop\n    */\n    stop: function(callback) {\n      var t = this, server = t.get('server'), router = Monitor.getRouter();\n      callback = callback || function(){};\n\n      // Call the callback, but don't stop more than once.\n      if (!t.isListening) {\n        return callback();\n      }\n\n      // Release resources\n      t.connections.each(router.removeConnection, router);\n      t.connections.reset();\n\n      // Shut down the server\n      t.isListening = false;\n      server.close();\n\n      // Send notices\n      t.trigger('stop');\n      return callback();\n    }\n  });\n\n  /**\n  * Constructor for a list of Server objects\n  *\n  *     var myList = new Server.List(initialElements);\n  *\n  * @static\n  * @method List\n  * @param [items] {Array} Initial list items.  These can be raw JS objects or Server data model objects.\n  * @return {Backbone.Collection} Collection of Server data model objects\n  */\n  Server.List = Backbone.Collection.extend({model: Server});\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Router.js":"// Router.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('./Monitor'),\n      log = Monitor.getLogger('Router'),\n      stat = Monitor.getStatLogger('Router'),\n      Cron = Monitor.Cron, _ = Monitor._, Backbone = Monitor.Backbone,\n      Config = Monitor.Config, Probe = Monitor.Probe,\n      Connection = Monitor.Connection, Server = Monitor.Server,\n      SocketIO = root.io || require('socket.io'),\n\n      // Set if server-side\n      hostName = Monitor.commonJS ? require('os').hostname() : null;\n\n  // Constants\n  var PROBE_TIMEOUT_MS = 10000;\n\n  /**\n  * Probe location and message routing\n  *\n  * The router is a class used internally to locate probes and connect\n  * events so messages are correctly routed between probes and their monitors.\n  *\n  * It is a *singleton* class, designed to run one instance within\n  * a monitor process, and accessed via the (protected) `getRouter()`\n  * method of the <a href=\"Monitor.html\">Monitor</a> object.\n  *\n  * It manages all outbound requests to probes, either internally or externally\n  * via the <a href=\"Connection.html\">Connection</a> to the remote process.\n  *\n  * @class Router\n  * @extends Backbone.Model\n  * @constructor\n  */\n  /**\n  * A new connection has been established\n  *\n  * @event\n  * connection:add\n  * @param connection {Connection} The added connection\n  */\n  /**\n  * A connection has been terminated\n  *\n  * @event\n  * connection:remove\n  * @param connection {Connection} The removed connection\n  */\n  var Router = Monitor.Router = Backbone.Model.extend({\n\n    initialize: function() {\n      var t = this;\n      t.defaultGateway = null;\n      t.firewall = false;\n      t.connections = new Connection.List();\n      t.runningProbesByKey = {}; // key=probeKey, data=probeImpl\n      t.runningProbesById = {};  // key=probeId, data=probeImpl\n      t.addHostCallbacks = {};  // key=hostName, data=[callbacks]\n      log.info('init', 'Router initialized');\n    },\n\n    /**\n    * Firewall new connections from inbound probe requests\n    *\n    * When two monitor processes connect, they become peers.  By default each\n    * process can request probe connections with the other.\n    *\n    * If you want to connect with a remote probe, but don't want those servers\n    * to connect with probes in this process, call this method to firewall\n    * those inbound probe requests.\n    *\n    * Setting this will change the firewall value for all *new* connections.\n    * Any existing connections will still accept incoming probe requests.\n    *\n    * @static\n    * @method setFirewall\n    * @param firewall {Boolean} - Firewall new connections?\n    */\n    setFirewall: function(firewall) {\n      var t = Monitor.getRouter(); // This is a static method\n      t.firewall = firewall;\n      log.info('setFirewall', firewall);\n    },\n\n    /**\n    * Set the default gateway server\n    *\n    * The gateway server is used if a monitor cannot connect directly with the\n    * server hosting the probe.\n    *\n    * When a monitor is requested to connect with a probe on a specific server,\n    * a direct connection is attempted.  If that direct connection fails, usually\n    * due to a firewall or browser restriction, the monitor will attempt the\n    * connection to the probe through the gateway server.\n    *\n    * The server specified in this method must have been started as a gateway\n    * like this:\n    *\n    *     // Start a monitor server and act as a gateway\n    *     var server = new Monitor.Server({gateway:true});\n    *\n    * @method setGateway\n    * @param options {Object} - Connection parameters\n    *   @param options.hostName {String} - Name of the gateway host\n    *   @param options.hostPort {Integer} - Port number to connect with\n    *   @param options.url {String} - The URL used to connect (created, or used if supplied)\n    *   @param options.socket {io.socket} - Pre-connected socket.io socket to the gateway server.\n    * @return connection {Connection} - The connection with the gateway server\n    */\n    setGateway: function(options) {\n      var t = this;\n      options.gateway = false;     // New connection can't be an inbound gateway\n      options.firewall = true;     // Gateways are for outbound requests only\n      return t.defaultGateway = t.addConnection(options);\n    },\n\n    /**\n    * Return a stable host name.\n    *\n    * @method getHostName\n    * @protected\n    * @return hostName {String} - The platform's host name, or an otherwise stable ID\n    */\n    getHostName: function() {\n      var localStorage = root.localStorage;\n      if (!hostName) {\n        if (localStorage) {hostName = localStorage.hostName;}\n        hostName = hostName || Monitor.generateUniqueId();\n        if (localStorage) {localStorage.hostName = hostName;}\n      }\n      return hostName;\n    },\n\n    /**\n    * Set the current host name.\n    *\n    * This sets the host name that this router publishes to new connections.\n    * It's only useful if the os hostname isn't the name you want to publish.\n    *\n    * @protected\n    * @method setHostName\n    * @param hostName {String} - The host name to publish to new connections\n    */\n    setHostName: function(name) {\n      hostName = name;\n      log.info('setHostName', name);\n    },\n\n    /**\n    * Add a connection to a remote Monitor process\n    *\n    * @method addConnection\n    * @protected\n    * @param options {Object} - Connection parameters\n    *   @param options.hostName {String} - Name of the host to connect with\n    *   @param options.hostPort {Integer} - Port number to connect with\n    *   @param options.url {String} - The URL used to connect (created, or used if supplied)\n    *   @param options.socket {io.socket} - Pre-connected socket.io socket to a Monitor server.\n    *   @param options.gateway {Boolean} - Allow this connection to use me as a gateway (default false)\n    *   @param options.firewall {Boolean} Firewall inbound probe requests on this connection?\n    * @return connection {Connection} - The added connection\n    */\n    addConnection: function(options) {\n      var t = this,\n          startTime = Date.now();\n\n      // Default the firewall value\n      if (_.isUndefined(options.firewall)) {\n        options = _.extend({},options, {firewall: t.firewall});\n      }\n\n      // Generate a unique ID for the connection\n      options.id = Monitor.generateUniqueCollectionId(t.connections);\n\n      var connStr = 'Conn_' + options.id;\n      if (options.hostName) {\n        connStr += ' - ' + options.hostName + ':' + options.hostPort;\n      }\n      log.info('addConnection', connStr);\n\n      // Instantiate and add the connection for use, once connected\n      var connection = new Connection(options);\n\n      // Add a connect and disconnect function\n      var onConnect = function(){\n        t.trigger('connection:add', connection);\n        log.info('connected', connStr, (Date.now() - startTime) + 'ms');\n      };\n      var onDisconnect = function(){\n        t.removeConnection(connection);\n        connection.off('connect', onConnect);\n        connection.off('disconnect', onConnect);\n        log.info('disconnected', connStr, (Date.now() - startTime) + 'ms');\n      };\n      connection.on('connect', onConnect);\n      connection.on('disconnect', onDisconnect);\n\n      // Add to the connections\n      t.connections.add(connection);\n      return connection;\n    },\n\n    /**\n    * Remove a connection from the router.\n    *\n    * This is called to remove the connection and associated routes from the router.\n    *\n    * @method removeConnection\n    * @protected\n    * @param connection {Connection} - The connection to remove\n    */\n    removeConnection: function(connection) {\n      var t = this;\n      log.info('removeConnection', 'Conn_' + connection.id);\n      connection.disconnect('connection_removed');\n      t.connections.remove(connection);\n      t.trigger('connection:remove', connection);\n    },\n\n    /**\n    * Connect a Monitor object to a remote Probe\n    *\n    * This accepts an instance of a Monitor and figures out how to connect it\n    * to a running Probe.\n    *\n    * Upon callback the probe data is set into the monitor (unless an error\n    * occurred)\n    *\n    * @method connectMonitor\n    * @protected\n    * @param monitor {Monitor} - The monitor requesting to connect with the probe\n    * @param callback {Function(error)} - (optional) Called when connected\n    */\n    connectMonitor: function(monitor, callback) {\n\n      callback = callback || function(){};\n      var t = this,\n          monitorJSON = monitor.toMonitorJSON(),\n          probeJSON = null,\n          probeName = monitorJSON.probeName,\n          probeClass = monitorJSON.probeClass,\n          startTime = Date.now(),\n          monitorStr = probeClass + '.' + monitor.toServerString().replace(/:/g, '.');\n\n      // Class name must be set\n      if (!probeClass && !probeName) {\n        var errStr = 'probeName or probeClass must be set';\n        log.error('connectMonitor', errStr);\n        return callback(errStr);\n      }\n\n      // Determine the connection (or internal), and listen for change events\n      t.determineConnection(monitorJSON, true, function(err, connection) {\n        if (err) {return callback(err);}\n\n        // Function to run on connection (internal or external)\n        var onConnect = function(error, probe) {\n          if (error) {return callback(error);}\n          probeJSON = probe.toJSON();\n          probeJSON.probeId = probeJSON.id; delete probeJSON.id;\n          monitor.probe = probe;\n\n          // Keep the last known probe state for effective updating\n          monitor._probeValues = _.clone(probeJSON);\n\n          // Perform the initial set silently.  This assures the initial\n          // probe contents are available on the connect event,\n          // but doesn't fire a change event before connect.\n          monitor.set(probeJSON, {silent:true});\n\n          // Watch the probe for changes.\n          monitor.probeChange = function(){\n            var changed = probe.changedAttributes();\n            if (changed) {\n              monitor._probeValues = _.clone(probe.toJSON());\n              monitor.set(probe.changedAttributes());\n              log.info('probeChange', {probeId: probeJSON.probeId, changed: probe.changedAttributes()});\n            }\n          };\n          probe.on('change', monitor.probeChange);\n\n          // Call the callback.  This calls the original caller, issues\n          // the connect event, then fires the initial change event.\n          callback(null);\n        };\n\n        // Connect internally or externally\n        if (connection) {\n          t.connectExternal(monitorJSON, connection, onConnect);\n        } else {\n          t.connectInternal(monitorJSON, onConnect);\n        }\n      });\n    },\n\n    /**\n    * Disconnect a monitor\n    *\n    * This accepts an instance of a connected monitor, and disconnects it from\n    * the remote probe.\n    *\n    * The probe implementation will be released if this is the only monitor\n    * object watching it.\n    *\n    * @method disconnectMonitor\n    * @protected\n    * @param monitor {Monitor} - The connected monitor\n    * @param reason {String} - Reason for the disconnect\n    * @param callback {Function(error)} - (optional) Called when connected\n    */\n    disconnectMonitor: function(monitor, reason, callback) {\n      callback = callback || function(){};\n      var t = this, probe = monitor.probe, probeId = monitor.get('probeId');\n\n      // The monitor must be connected\n      if (!probe) {return callback('Monitor must be connected');}\n\n      // Called upon disconnect (internal or external)\n      var onDisconnect = function(error) {\n        if (error) {\n          return callback(error);\n        }\n        probe.off('change', monitor.probeChange);\n        monitor.set({probeId:null});\n        monitor.probe = monitor.probeChange = null;\n        return callback(null, reason);\n      };\n\n      // Disconnect from an internal or external probe\n      if (probe.connection) {\n        t.disconnectExternal(probe.connection, probeId, onDisconnect);\n      } else {\n        t.disconnectInternal(probeId, onDisconnect);\n      }\n    },\n\n    /**\n    * Build a probe key from the probe data\n    *\n    * @method buildProbeKey\n    * @protected\n    * @param probeJSON {Object} - An object containing:\n    *     @param probeJSON.probeName {String} - The client-defined probe name\n    *     -or-\n    *     @param probeJSON.probeClass {String} - The probe class name (required)\n    *     @param probeJSON.initParams {Object} - Probe initialization parameters (if any)\n    * @return probeKey {String} - A string identifying the probe\n    */\n    buildProbeKey: function(probeJSON) {\n      var probeKey = probeJSON.probeClass,\n          initParams = probeJSON.initParams;\n\n      // Allow probes to be externally identified by name\n      if (probeJSON.probeName) {\n        return probeJSON.probeName;\n      }\n\n      if (initParams) {\n        _.keys(initParams).sort().forEach(function(key){\n          probeKey += ':' + key + '=' + initParams[key];\n        });\n      }\n      return probeKey;\n    },\n\n    /**\n    * Determine the connection to use for a probe\n    *\n    * This uses the connection parameters of the specified monitor to determine\n    * (or create) the connection to use for the probe.\n    *\n    * If the probe can be instantiated internally, a null is returned as the\n    * connection.\n    *\n    * This attempts to use an existing connection if available.  If not, a\n    * connection attempt will be made with the host. If the host cannot be\n    * reached directly, it returns a connection with the gateway.\n    *\n    * @method determineConnection\n    * @protected\n    * @param monitorJSON {Object} - The connection attributes of the monitor\n    * @param makeNewConnections {Boolean} - Establish a new connection if one doesn't exist?\n    * @param callback {Function(error, connection)} - Called when the connection is known\n    * <ul>\n    *   <li>error - Set if any errors</li>\n    *   <li>connection - The connection object, or null to run in this process</li>\n    * <ul>\n    */\n    determineConnection: function(monitorJSON, makeNewConnections, callback) {\n      var t = this,\n          connection = null,\n          probeName = monitorJSON.probeName,\n          probeClass = monitorJSON.probeClass,\n          errStr = '',\n          hostName = monitorJSON.hostName,\n          appName = monitorJSON.appName,\n          appInstance = monitorJSON.appInstance,\n          thisHostName = t.getHostName().toLowerCase(),\n          thisAppName = Config.Monitor.appName  || 'unknown',\n          thisAppInstance = typeof process !== 'undefined' ? process.env.NODE_APP_INSTANCE : '1';\n\n      // Return a found connection immediately if it's connected.\n      // If connecting, wait for connection to complete.\n      // If not connected (and not connecting) re-try the connection.\n      var connectedCheck = function(isGateway) {\n\n        // Remove the host/app/instance params if connecting directly.\n        if (!isGateway) {\n          delete monitorJSON.hostName;\n          delete monitorJSON.appName;\n          delete monitorJSON.appInstance;\n        }\n\n        // Define the connect/error listeners\n        var onConnect = function() {\n          removeListeners();\n          callback(null, connection);\n        };\n        var onError = function(err) {\n          removeListeners();\n          log.error('connect.error', err);\n          callback({msg: 'connection error', err:err});\n        };\n        var removeListeners = function() {\n          connection.off('connect', onConnect);\n          connection.off('error', onError);\n        };\n\n        // Wait if the connection is still awaiting connect\n        if (connection && connection.connecting) {\n          connection.on('connect', onConnect);\n          connection.on('error', onError);\n          return;\n        }\n\n        // Re-try if disconnected\n        if (connection && !connection.connected) {\n          connection.on('connect', onConnect);\n          connection.on('error', onError);\n          return connection.connect();\n        }\n\n        // Verified connection\n        return callback(null, connection);\n      };\n\n      // Connect with this process (internally)?\n      hostName = hostName ? hostName.toLowerCase() : null;\n      var thisHost = (!hostName || hostName === thisHostName);\n      var thisApp = (!appName || appName === thisAppName);\n      var thisInstance = (!appInstance || appInstance === thisAppInstance);\n      if (thisHost && thisApp && thisInstance) {\n\n        // Connect internally if the probe is available\n        if (t.runningProbesByKey[probeName] || Probe.classes[probeClass] != null) {\n          return callback(null, null);\n        }\n\n        // Give named auto-start probes time to start up\n        var autoStarts = Monitor.Config.Monitor.autoStart;\n        if (probeName && !probeClass && autoStarts.length) {\n          var autoStart = Monitor._.find(autoStarts, function(probeDef) {\n            return probeDef.probeName === probeName;\n          });\n          if (autoStart) {\n            setTimeout(function() {\n              t.determineConnection(monitorJSON, makeNewConnections, callback);\n            },10);\n            return;\n          }\n        }\n\n        // No probe with that name in this process.\n        // Fallback to the default gateway.\n        if (!t.defaultGateway) {\n          errStr = 'Probe class \"' + probeClass + '\" not available in this process';\n          log.error('connect.internal', errStr);\n          return callback({err:errStr});\n        }\n        connection = t.defaultGateway;\n        return connectedCheck(true);\n      }\n\n      // Return if connection is known\n      connection = t.findConnection(hostName, appName, appInstance);\n      if (connection) {\n        return connectedCheck();\n      }\n\n      // Prefer the gateway if it exists\n      if (t.defaultGateway) {\n        connection = t.defaultGateway;\n        return connectedCheck(true);\n      }\n\n      // See if we can establish new connections with the host\n      if (hostName && makeNewConnections) {\n        t.addHostConnections(hostName, function(err) {\n          if (err) {\n            log.error('connect.toHost', err);\n            return callback(err);\n          }\n\n          // Try finding now that new connections have been made\n          connection = t.findConnection(hostName, appName, appInstance);\n          if (!connection) {\n            errStr = 'No route to host: ' + Monitor.toServerString(monitorJSON);\n            log.error('connect.toHost', errStr);\n            return callback({err:errStr});\n          }\n\n          return connectedCheck();\n        });\n\n        // Wait for addHostConnections to complete\n        return;\n      }\n\n      // We tried...\n      if (!hostName) {\n        // App name was specified, it wasn't this process, and no hostname\n        errStr = 'No host specified for app: ' + appName;\n        log.error('connect', errStr);\n        return callback({msg:errStr},null);\n      } else {\n        // Not allowed to try remote hosts\n        errStr = 'Not a gateway to remote monitors';\n        log.error('connect', errStr);\n        return callback({msg:errStr});\n      }\n    },\n\n    /**\n    * Find an existing connection to use\n    *\n    * This method looks into the existing known connections to find one\n    * that matches the specified parameters.\n    *\n    * Firewalled connections are not returned.\n    *\n    * @method findConnection\n    * @protected\n    * @param hostName {String} - Host name to find a connection for (null = any host)\n    * @param appName {String} - App name to find a connection with (null = any app)\n    * @param appInstance {Any} - Application instance running on this host (null = any instance)\n    * @return connection {Connection} - A Connection object if found, otherwise null\n    */\n    findConnection: function(hostName, appName, appInstance) {\n      var t = this, thisInstance = 0;\n      return t.connections.find(function(conn) {\n\n        // Host or app matches if not specified or if specified and equal\n        var matchesHost = !hostName || conn.isThisHost(hostName);\n        var matchesApp = !appName || appName === conn.get('remoteAppName');\n        var matchesInstance = !appInstance || appInstance === conn.get('remoteAppInstance');\n        var remoteFirewall = conn.get('remoteFirewall');\n\n        // This is a match if host + app + instance matches, and it's not firewalled\n        return (!remoteFirewall && matchesHost && matchesApp && matchesInstance);\n      });\n    },\n\n    /**\n    * Find all connections matching the selection criteria\n    *\n    * This method looks into the existing known connections to find all\n    * that match the specified parameters.\n    *\n    * Firewalled connections are not returned.\n    *\n    * @method findConnections\n    * @protected\n    * @param hostName {String} - Host name to search for (null = any host)\n    * @param appName {String} - App name to search for (null = any app)\n    * @return connections {Array of Connection} - An array of Connection objects matching the criteria\n    */\n    findConnections: function(hostName, appName) {\n      var t = this;\n      return t.connections.filter(function(conn) {\n\n        // Host or app matches if not specified or if specified and equal\n        var matchesHost = !hostName || conn.isThisHost(hostName);\n        var matchesApp = !appName || appName === conn.get('remoteAppName');\n        var remoteFirewall = conn.get('remoteFirewall');\n\n        // This is a match if host + app matches, and it's not firewalled\n        return (!remoteFirewall && matchesHost && matchesApp);\n      });\n    },\n\n    /**\n    * Add connections for the specified host\n    *\n    * This performs a scan of monitor ports on the server, and adds connections\n    * for newly discovered servers.\n    *\n    * It can take a while to complete, and if called for the same host before\n    * completion, it will save the callback and call all callbacks when the\n    * original task is complete.\n    *\n    * @method addHostConnections\n    * @protected\n    * @param hostName {String} - The host to add connections with\n    * @param callback {Function(error)} - Called when complete\n    */\n    addHostConnections: function(hostName, callback) {\n      var t = this,\n          errStr = '',\n          connectedPorts = [],\n          portStart = Config.Monitor.serviceBasePort,\n          portEnd = Config.Monitor.serviceBasePort + Config.Monitor.portsToScan - 1;\n\n      // Create an array to hold callbacks for this host\n      if (!t.addHostCallbacks[hostName]) {\n        t.addHostCallbacks[hostName] = [];\n      }\n\n      // Remember this callback and return if we're already adding connections for this host\n      if (t.addHostCallbacks[hostName].push(callback) > 1) {\n        return;\n      }\n\n      // Called when done\n      var doneAdding = function(error) {\n        t.addHostCallbacks[hostName].forEach(function(cb) {\n          cb(error);\n        });\n        delete t.addHostCallbacks[hostName];\n      };\n\n      // Build the list of ports already connected\n      t.connections.each(function(connection){\n        var host = connection.get('hostName').toLowerCase();\n        var port = connection.get('hostPort');\n        if (host === hostName && port >= portStart && port <= portEnd) {\n          connectedPorts.push(port);\n        }\n      });\n\n      // Scan non-connected ports\n      var portsToScan = Config.Monitor.portsToScan - connectedPorts.length;\n      if (portsToScan === 0) {\n        errStr = 'All monitor ports in use.  Increase the Config.Monitor.portsToScan configuration';\n        log.error('addHostConnections', errStr);\n        return doneAdding(errStr);\n      }\n      var doneScanning = function() {\n        var conn = this; // called in the context of the connection\n        conn.off('connect disconnect error', doneScanning);\n        if (--portsToScan === 0) {\n          return doneAdding();\n        }\n      };\n      for (var i = portStart; i <= portEnd; i++) {\n        if (connectedPorts.indexOf(i) < 0) {\n          var connection = t.addConnection({hostName:hostName, hostPort:i});\n          connection.on('connect disconnect error', doneScanning, connection);\n        }\n      }\n    },\n\n    /**\n    * Connect to an internal probe implementation\n    *\n    * This connects with a probe running in this process.  It will instantiate\n    * the probe if it isn't currently running.\n    *\n    * @method connectInternal\n    * @protected\n    * @param monitorJSON {Object} - The monitor toJSON data.  Containing:\n    *     @param monitorJSON.probeClass {String} - The probe class name to connect with (required)\n    *     @param monitorJSON.initParams {Object} - Probe initialization parameters.\n    * @param callback {Function(error, probeImpl)} - Called when connected\n    */\n    connectInternal: function(monitorJSON, callback) {\n\n      // Build a key for this probe from the probeClass and initParams\n      var t = this,\n          probeKey = t.buildProbeKey(monitorJSON),\n          probeName = monitorJSON.probeName,\n          probeClass = monitorJSON.probeClass,\n          initParams = monitorJSON.initParams,\n          probeImpl = null;\n\n      var whenDone = function(error) {\n\n        // Wait one tick before firing the callback.  This simulates a remote\n        // connection, making the client callback order consistent, regardless\n        // of a local or remote connection.\n        setTimeout(function() {\n\n          // Dont connect the probe on error\n          if (error) {\n            if (probeImpl) {\n              delete t.runningProbesByKey[probeKey];\n              delete t.runningProbesById[probeImpl.id];\n              try {\n                // This may fail depending on how many resources were created\n                // by the probe before failure.  Ignore errors.\n                probeImpl.release();\n              } catch (e){}\n            }\n            return callback(error);\n          }\n\n          // Probes are released based on reference count\n          probeImpl.refCount++;\n          log.info('connectInternal', {probeKey: probeKey, probeId: probeImpl.id});\n          callback(null, probeImpl);\n        }, 0);\n      };\n\n      // Get the probe instance\n      probeImpl = t.runningProbesByKey[probeKey];\n      if (!probeImpl) {\n\n        // Instantiate the probe\n        var ProbeClass = Probe.classes[probeClass];\n        if (!ProbeClass) {\n          return whenDone({msg:'Probe not available: ' + probeClass});\n        }\n        var initOptions = {asyncInit: false, callback: whenDone};\n        try {\n          // Deep copy the init params, because Backbone mutates them.  This\n          // is bad if the init params came in from defaults of another object,\n          // because those defaults will get mutated.\n          var paramCopy = Monitor.deepCopy(initParams);\n\n          // Extend the probe name into the probe if known\n          if (probeName) {\n            paramCopy.probeName = probeName;\n          }\n\n          // Instantiate a new probe\n          probeImpl = new ProbeClass(paramCopy, initOptions);\n          probeImpl.set({\n            id: Monitor.generateUniqueId(),\n            writableAttributes: ProbeClass.prototype.writableAttributes || []\n          });\n          probeImpl.refCount = 0;\n          probeImpl.probeKey = probeKey;\n          t.runningProbesByKey[probeKey] = probeImpl;\n          t.runningProbesById[probeImpl.id] = probeImpl;\n        } catch (e) {\n          var error = {msg: 'Error instantiating probe ' + probeClass, error: e.message};\n          return whenDone(error);\n        }\n\n        // Return early if the probe constructor transferred responsibility\n        // for calling the callback.\n        if (initOptions.asyncInit) {\n          return;\n        }\n      }\n\n      // The probe impl is found, and instantiated if necessary\n      whenDone();\n    },\n\n    /**\n    * Disconnect with an internal probe implementation.\n    *\n    * @method disconnectInternal\n    * @protected\n    * @param probeId {String} - The probe implementation ID to disconnect\n    * @param callback {Function(error, probeImpl)} - Called when disconnected\n    */\n    disconnectInternal: function(probeId, callback) {\n      var t = this, probeImpl = t.runningProbesById[probeId];\n      if (!probeImpl) {return callback('Probe not running');}\n      if (--probeImpl.refCount === 0) {\n\n        // Release probe resources & internal references if still no references after a while\n        setTimeout(function() {\n          if (probeImpl.refCount === 0) {\n            try {\n              probeImpl.release();\n            } catch (e){}\n            delete t.runningProbesByKey[probeImpl.probeKey];\n            delete t.runningProbesById[probeId];\n          }\n        }, PROBE_TIMEOUT_MS);\n      }\n      callback(null, probeImpl);\n    },\n\n    /**\n    * Connect to an external probe implementation.\n    *\n    * This connects with a probe running in another process.  It will\n    * coordinate the remote instantiation of the probe if it's not running.\n    *\n    * @method connectExternal\n    * @protected\n    * @param monitorJSON {Object} - An object containing:\n    *     @param monitorJSON.probeClass {String} - The probe class name (required)\n    *     @param monitorJSON.initParams {Object} - Probe initialization parameters (if any)\n    * @param connection {Connection} - The connection to use\n    * @param callback {Function(error, probeProxy)} - Called when connected\n    */\n    connectExternal: function(monitorJSON, connection, callback) {\n\n      // Build a key for this probe from the probeClass and initParams\n      var t = this,\n          errStr = '',\n          probeKey = t.buildProbeKey(monitorJSON);\n\n      // Get the probe proxy\n      var probeId = connection.remoteProbeIdsByKey[probeKey];\n      var probeProxy = connection.remoteProbesById[probeId];\n\n      if (!probeProxy) {\n\n        // Connect with the remote probe\n        connection.emit('probe:connect', monitorJSON, function(error, probeJSON){\n          if (error) {\n            errStr = \"probe:connect returned an error for probeClass '\" + monitorJSON.probeClass +\n              \"' on \" + Monitor.toServerString(monitorJSON);\n            return callback({err: error, msg: errStr});\n          }\n          probeId = probeJSON.id;\n\n          // See if the proxy was created while waiting for return\n          probeProxy = connection.remoteProbesById[probeId];\n          if (probeProxy) {\n            probeProxy.refCount++;\n            log.info('connectExternal.connected.existingProxy', {probeId: probeId, refCount: probeProxy.refCount, whileWaiting: true});\n            return callback(null, probeProxy);\n          }\n\n          // Create the probe proxy\n          probeProxy = new Probe(probeJSON);\n          probeProxy.refCount = 1;\n          probeProxy.connection = connection;\n          connection.remoteProbeIdsByKey[probeKey] = probeId;\n          connection.remoteProbesById[probeId] = probeProxy;\n          connection.addEvent('probe:change:' + probeId, function(attrs){probeProxy.set(attrs);});\n          log.info('connectExternal.connected.newProxy', {probeId: probeId});\n          return callback(null, probeProxy);\n        });\n        return;\n      }\n\n      // Probes are released based on reference count\n      probeProxy.refCount++;\n      log.info('connectExternal.connected.existingProxy', {probeId: probeId, refCount: probeProxy.refCount});\n      return callback(null, probeProxy);\n    },\n\n    /**\n    * Disconnect with an external probe implementation.\n    *\n    * @method disconnectExternal\n    * @protected\n    * @param connection {Connection} - The connection to use\n    * @param probeId {String} - Probe ID\n    * @param callback {Function(error)} - Called when disconnected\n    */\n    disconnectExternal: function(connection, probeId, callback) {\n      var t = this, proxy = connection.remoteProbesById[probeId];\n      if (!proxy) {return callback('Probe not running');}\n      if (--proxy.refCount === 0) {\n        // Release probe resources\n        proxy.release();\n        proxy.connection = null;\n        delete connection.remoteProbesById[probeId];\n        delete connection.remoteProbeIdsByKey[proxy.probeKey];\n        connection.removeEvent('probe:change:' + probeId);\n        return connection.emit('probe:disconnect', {probeId:probeId}, function(error){\n          return callback(error);\n        });\n      }\n      callback(null);\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/Sync.js":"// Sync.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('./Monitor'),\n      logger = Monitor.getLogger('Sync'),\n      Backbone = Monitor.Backbone,\n      _ = Monitor._;\n\n  // Constants\n  var METHOD_CREATE = 'create',\n      METHOD_READ = 'read',\n      METHOD_UPDATE = 'update',\n      METHOD_DELETE = 'delete';\n\n  /**\n  * Probe based data synchronization with server-side storage.\n  *\n  * This method returns a function conforming to the Backbone\n  * <a href=\"http://documentcloud.github.com/backbone/#Sync\">Sync</a>\n  * API, offering\n  * <a href=\"http://documentcloud.github.com/backbone/#Model-fetch\">```fetch```</a>,\n  * <a href=\"http://documentcloud.github.com/backbone/#Model-save\">```save```</a>, and\n  * <a href=\"http://documentcloud.github.com/backbone/#Model-destroy\">```destroy```</a>\n  * functionality to any Backbone data model.\n  *\n  * The returned function can be assigned to the ```sync``` element when defining the\n  * data model:\n  *\n  *     var BlogEntry = Backbone.Model.extend({\n  *       ...\n  *       sync: Monitor.Sync('BlogEntry'),\n  *       ...\n  *     });\n  *\n  * The sync function can also be assigned to any Backbone model after construction:\n  *\n  *     var myBook = new Book({id:\"44329\"});\n  *     myBook.sync = Monitor.Sync('Book');\n  *     myBook.fetch();\n  *\n  * In addition to providing the standard ```fetch```, ```save```, and ```destroy```\n  * functionality, Sync offers *live data synchronization*, updating the data model\n  * as changes are detected on the server.\n  *\n  *     // Turn on live data synchronization\n  *     myBook.fetch({liveSync:true});\n  *\n  * This fetches the ```myBook``` instance with the contents of the Book class\n  * id ```44329```, persists local changes to ```myBook```, and keeps ```myBook```\n  * up to date with changes detected on the server.\n  *\n  * Live data synchronization consumes resources on both the client and server.\n  * To release those resources, make sure to call the ```clear()``` method on\n  * the data model. Otherwise, resources are released when the server connection\n  * is terminated.\n  *\n  *     // Clear the object, turning off live synchronization\n  *     myBook.clear();\n  *\n  * See the <a href=\"http://documentcloud.github.com/backbone/#Sync\">Backbone documentation</a>\n  * for more information about the Backbone.sync functionality.\n  *\n  * @static\n  * @method Sync\n  * @param className {String} Name of the class to synchronize with\n  * @param [options] {Object} Additional sync options\n  *     @param options.hostName {String} Host name to use for the Sync probe.\n  *       If not specified, the closest server hosting Sync probe will be\n  *       determined (this server, or the default gateway)\n  *     @param options.appName {String} Server appName (see Monitor.appName)\n  *     @param options.appInstance {String} Application instance (see Monitor.appInstance)\n  * @return {sync} A sync method to assign to a Backbone class or instance.\n  */\n  Monitor.Sync = function(className, options) {\n    if (!className) {\n      throw new Error('Sync class name must be provided');\n    }\n\n    // Get a Sync object and bind it to the sync function\n    var syncObj = new Sync(className, options);\n    return function(method, model, options) {\n      logger.info('sync', {className: className, method:method, model:model.toJSON(), options:options});\n      return syncObj._sync(method, model, options);\n    };\n  };\n\n  /**\n  * Live data model synchronization.\n  *\n  * This class can be attached to Backbone models to synchronize backend data using the\n  * <a href=\"http://documentcloud.github.com/backbone/#Model-fetch\">```fetch```</a>,\n  * <a href=\"http://documentcloud.github.com/backbone/#Model-save\">```save```</a>, and\n  * <a href=\"http://documentcloud.github.com/backbone/#Model-destroy\">```destroy```</a>\n  * Backbone API methods.\n  *\n  * It also provides two-way change based synchronization, updating data on the server as\n  * changes are made to the model, and updating the client model as changes are detected\n  * on the server.\n  *\n  * Communication is <a href=\"Probe.html\">Probe</a> based, leveraging the built-in\n  * connection, routing, and socket-io functionality.  The <a href=\"FileSyncProbe.html\">FileSyncProbe</a>\n  * is provided for file-based model persistence, and others can be written to\n  * implement alternate persistence mechanisms.\n  *\n  * @private\n  * @class Sync\n  */\n  var Sync = function(className, options) {\n    var t = this;\n    logger.info('syncInit', className, options);\n    t.className = className;\n    t.options = options || {};\n  };\n\n  /**\n  * Provide the sync API to a backbone data model\n  *\n  * See the <a href=\"http://documentcloud.github.com/backbone/#Sync\">Backbone documentation</a>\n  * for more information on this method.\n  *\n  * @private\n  * @method _sync\n  * @param method {String} A CRUD enumeration of \"create\", \"read\", \"update\", or \"delete\"\n  * @param model {Backbone.Model or Backbone.Collection} The model or collection to act upon\n  * @param [options] {Object} Success and error callbacks, and additional options to\n  *   pass on to the sync implementation.\n  *     @param [options.liveSync] - Turn on the live update functionality\n  *     @param [options.silenceErrors] - Silence the logging of errors (they're expected)\n  *     @param [options.success] - The method to call on method success\n  *     @param [options.error] - The method to call on method error\n  */\n  Sync.prototype._sync = function(method, model, options) {\n    var t = this;\n    options = options || {};\n\n    // Cannot liveSync with a collection (too many issues)\n    if (options.liveSync && model instanceof Backbone.Collection) {\n      return options.error(null, 'Cannot liveSync with a collection');\n    }\n\n    // Generate an ID if necessary\n    if (!model.has('id')) {\n      if (method === METHOD_CREATE) {\n        model.set({id: Monitor.generateUniqueId()}, {silent: true});\n        logger.info('_sync.generateUniqueId', t.className, model.toJSON(), options);\n      } else {\n        return options.error(null, 'ID element must be set.');\n      }\n    }\n\n    // Special case: LiveSync on CREATE.  LiveSync requires a persisted object,\n    // so if requesting liveSync on a create, we have to use the class monitor\n    // for the create, then get an instance monitor for the liveSync.\n    if (method === METHOD_CREATE && options.liveSync) {\n      // Call this method again without liveSync (this uses the class monitor)\n      t._sync(method, model, {error: options.error, success: function(params){\n        // Now connect w/liveSync using a fetch\n        t._sync(METHOD_READ, model, options);\n      }});\n      return;\n    }\n\n    // Create a function to run once complete\n    var onComplete = function(error, params) {\n      if (error) {\n        if (!options.silenceErrors) {\n          logger.error('_sync.onComplete', t.className, error);\n        }\n        options.error(null, error);\n      } else {\n        logger.info('_sync.onComplete', t.className, model.get('id'));\n        options.success(params);\n      }\n    };\n\n    // Is the proper syncMonitor already connected?\n    if (model.syncMonitor || (t.syncMonitor && !options.liveSync)) {\n\n      // Send the control message to the connected monitor\n      var syncMonitor = model.syncMonitor || t.syncMonitor;\n      var opts = t._getOpts(method, model);\n      syncMonitor.control(method, opts, onComplete);\n\n    } else {\n\n      // Connect an instance level syncMonitor to the model if liveSync\n      // is specified, otherwise create a class level syncMonitor\n      if (options.liveSync) {\n        t._connectInstanceMonitor(method, model, options, onComplete);\n      } else {\n        t._connectClassMonitor(method, model, options, onComplete);\n      }\n    }\n\n  };\n\n  /**\n  * Connect and send the control message to a Sync probe for this class.\n  *\n  * This creates a monitor to a Sync probe with the specified className.\n  * The monitor is used to send CRUD control messages for any ID within\n  * the class.\n  *\n  * Once connected, it sends the specified control message to the probe.\n  *\n  * This monitor is used for non-liveSync interactions.\n  *\n  * @private\n  * @method _connectClassMonitor\n  * @param method {String} The requested CRUD method\n  * @param model {Backbone.Model} The data model to perform the operation on\n  * @param [options] {Object} Options\n  *     @param [options.silenceErrors] - Silence the logging of errors (they're expected)\n  * @param callback {function(error, params)} - Called when connected\n  *     @param callback.error {Mixed} - Set if it couldn't connect\n  *     @param callback.params {Object} - Updated data model parameters\n  */\n  Sync.prototype._connectClassMonitor = function(method, model, options, callback) {\n    var t = this;\n\n    // Connect a syncMonitor for the class\n    logger.info('connectClassMonitor', t.className, method, model.toJSON());\n    var monitorParams = t._getMonitorParams(null);\n    var syncMonitor = new Monitor(monitorParams);\n    syncMonitor.connect(function(error){\n      if (error) {\n        if (!options.silenceErrors) {\n          logger.error('connectClassMonitor', error);\n        }\n        return callback(error);\n      }\n\n      // Attach the syncMonitor and forward the initial control message\n      t.syncMonitor = syncMonitor;\n      var opts = t._getOpts(method, model);\n      syncMonitor.control(method, opts, callback);\n    });\n  };\n\n  /**\n  * Connect and send the control message to a liveSync monitor for the model\n  *\n  * This creates a monitor to a Sync probe for the model instance, and\n  * attaches event listeners onto the monitor and the data model.\n  *\n  * Once connected, it sends the specified control message to the probe.\n  *\n  * Changes on the server are automatically propagated to the local\n  * data model, and local changes to the data model are automatically\n  * propagated to the server.\n  *\n  * @private\n  * @method _connectInstanceMonitor\n  * @param method {String} The requested CRUD method\n  * @param model {Backbone.Model} The data model to perform the operation on\n  * @param callback {function(error, params)} - Called when connected\n  *     @param callback.error {Mixed} - Set if it couldn't connect\n  *     @param callback.params {Object} - Updated data model parameters\n  */\n  Sync.prototype._connectInstanceMonitor = function(method, model, options, callback) {\n    var t = this, syncMonitor, modelId = model.get('id');\n\n    // Called when done connecting\n    var whenDone = function(error) {\n\n      // Don't connect the instance monitor if errors\n      if (error) {\n        return callback(error);\n      }\n\n      // Called to disconnect the listeners\n      var disconnectListeners = function() {\n        logger.info('disconnectLiveSync', t.className, model.toJSON());\n        model.off('change', modelListener);\n        model.syncMonitor.off('change', monitorListener);\n        model.syncMonitor.disconnect();\n        model.syncMonitor = null;\n      };\n\n      // Client-side listener - for persisting changes to the server\n      var modelListener = function(changedModel, options) {\n        options = options || {};\n\n        // Don't persist unless the model is different\n        if (_.isEqual(JSON.parse(JSON.stringify(model)), JSON.parse(JSON.stringify(model.syncMonitor.get('model'))))) {\n          logger.info('modelListener.noChanges', t.className, model.toJSON());\n          return;\n        }\n\n        // Disconnect listeners if the ID changes\n        if (model.get('id') !== modelId) {\n          logger.info('modelListener.alteredId', t.className, model.toJSON());\n          return disconnectListeners();\n        }\n\n        // Persist changes to the server (unless the changes originated from there)\n        if (!options.isSyncChanging) {\n          logger.info('modelListener.saving', t.className, model.toJSON());\n          model.save();\n        }\n      };\n\n      // Server-side listener - for updating server changes into the model\n      var monitorListener = function(changedModel, options) {\n\n        // Don't update unless the model is different\n        var newModel = model.syncMonitor.get('model');\n        if (_.isEqual(JSON.parse(JSON.stringify(model)), JSON.parse(JSON.stringify(newModel)))) {\n          logger.info('monitorListener.noChanges', t.className, newModel);\n          return;\n        }\n\n        // Disconnect if the model was deleted or the ID isn't the same\n        var isDeleted = (_.size(newModel) === 0);\n        if (isDeleted || newModel.id !== modelId)  {\n          logger.info('modelListener.deleted', t.className, newModel);\n          disconnectListeners();\n        }\n\n        // Forward changes to the model (including server-side delete)\n        var newOpts = {isSyncChanging:true};\n        if (isDeleted) {\n          logger.info('modelListener.deleting', t.className, newModel);\n          model.clear(newOpts);\n        } else {\n          // Make sure the model is set to exactly the new contents (vs. override)\n          logger.info('modelListener.setting', t.className, newModel);\n          model.clear({silent:true});\n          model.set(newModel, newOpts);\n        }\n      };\n\n      // Connect the listeners\n      model.on('change', modelListener);\n      model.syncMonitor.on('change', monitorListener);\n\n      // Send back the initial data model\n      logger.info('connectInstanceMonitor.done', t.className, model.toJSON());\n      callback(null, model.syncMonitor.get('model'));\n    };\n\n    // Create a liveSync monitor for the model\n    var monitorParams = t._getMonitorParams(modelId);\n    syncMonitor = new Monitor(monitorParams);\n    syncMonitor.connect(function(error){\n      if (error) {\n        if (!options.silenceErrors) {\n          logger.error('connectInstanceMonitor.monitorConnect', error);\n        }\n        return whenDone(error);\n      }\n\n      // Attach the connected syncMonitor to the model\n      model.syncMonitor = syncMonitor;\n\n      // If the initial method is read, then the monitor already\n      // contains the results.  Otherwise, another round-trip is\n      // necessary for the initial control request.\n      if (method === METHOD_READ) {\n        return whenDone();\n      }\n\n      // Forward the initial control\n      var opts = t._getOpts(method, model);\n      logger.info('connectInstanceMonitor.forwarding', method, t.className, model.toJSON());\n      syncMonitor.control(method, opts, whenDone);\n    });\n  };\n\n  /**\n  * Prepare the control options\n  *\n  * This prepares the control options to include the ID element\n  * on a fetch or delete, and the entire model on a create or\n  * update.\n  *\n  * @private\n  * @method _getOpts\n  * @param method {Enum} One of the CRUD methods\n  * @param model {Backbone.Model} The model to prepare the opts from\n  * @return {Object} The options object to pass to the probe\n  */\n  Sync.prototype._getOpts = function(method, model) {\n    var opts = {};\n    switch (method) {\n      case METHOD_READ:\n      case METHOD_DELETE:\n        opts.id = model.get('id');\n        break;\n      case METHOD_CREATE:\n      case METHOD_UPDATE:\n        opts.model = model.toJSON();\n        break;\n    }\n    return opts;\n  };\n\n  /**\n  * Prepare the init parameters for a monitor to a Sync probe\n  *\n  * The monitor init params for the class monitor and the liveSync\n  * model monitor only differ in the modelId, so this method was\n  * broken out to reduce code duplication.\n  *\n  * @private\n  * @method _getMonitorParams\n  * @param [modelId] {String} Id to the data model.  If set, then params\n  *   will be built for liveSync to a data model with that id.\n  *   params for the class.\n  * @return {Object} The monitor parameters\n  */\n  Sync.prototype._getMonitorParams = function(modelId) {\n\n    // Build server connection parameters from this instance of Sync\n    var t = this;\n    var params = _.pick(t.options, 'hostName', 'appName', 'appInstance');\n\n    // Add probe and class parameters\n    params.probeClass = 'Sync';\n    params.initParams = {\n      className: t.className\n    };\n\n    // Add the model id if this is a liveSync probe\n    if (modelId) {\n      params.initParams.modelId = modelId;\n    }\n\n    return params;\n  };\n\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/DataModelProbe.js":"// DataModelProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor');\n\n  /**\n  * Probe representation of a simple data model\n  *\n  * This probe allows remote creation, manipulation, and change moitoring for\n  * arbitrary data. It is useful for monitor applications needing to maintain\n  * a small amount of state on the system being monitored.\n  *\n  * @class DataModelProbe\n  * @extends Probe\n  * @constructor\n  * @param [initParams] - Initialization parameters.  An object containing the\n  *   initial state of the data model.  All properties become data model\n  *   elements, readable and writable by all monitors connected to the probe.\n  */\n  var DataModelProbe = Monitor.DataModelProbe = Monitor.Probe.extend({\n\n    // These are required for Probes\n    probeClass: 'DataModel',\n    writableAttributes: '*'\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/RecipeProbe.js":"// RecipeProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n\n/* This class is evil.  You probably shouldn't use it. Or drink. Or drink while using it. */\n/*jslint evil: true */\n\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._,\n      Cron = Monitor.Cron,\n      logger = Monitor.getLogger('RecipeProbe'),\n      vm = Monitor.commonJS ? require('vm') : null,\n      Probe = Monitor.Probe;\n\n  /**\n  * Monitor automation probe\n  *\n  * The Recipe probe monitors other probes and runs instructions when the\n  * probes change, and controls other probes based on these instructions.\n  *\n  * It contains a list of monitors to instantiate, and a script to run when the\n  * monitor ```change``` event is fired.\n  *\n  * When the script fires, the monitors are available to the script by name.\n  * The script can ```get()``` monitor values, ```set()``` writable monitor\n  * values, and control the monitor using the ```control()`` method.\n  *\n  * The ```this``` variable is consistent between script runs, so state can be\n  * maintained by setting attributes in ```this```.\n  *\n  * @class RecipeProbe\n  * @extends Probe\n  * @constructor\n  * @param monitors {Object} - Named list of monitors to instantiate\n  *   Key: monitor variable name, Value: Monitor model parameters\n  * @param script {String} - JavaScript script to run.\n  *   The script has access to ```console```, ```logger```, and all defined\n  *   monitors by name.\n  * @param [recipeName] {String} - Recipe name for logging\n  * @param [autoStart=false] {boolean} - Call the start control on instantiation?\n  * @param [triggeredBy] {Object} - Trigger the recipe by the items in the object.\n  *        Items can include: 'interval', 'cron', and/or monitorName(s)\n  *        If 'interval' is the key, the value is the interval in milliseconds\n  *        If 'cron' is the key, the value is a string representing the cron pattern\n  *        If any monitor name is the key, the value is the monitor event to trigger on.\n  *        Example:\n  *        triggeredBy: {\n  *          interval: 5000,      // This triggers the recipe every 5 seconds\n  *          cron: '* * * * * *', // [second] [minute] [hour] [day of month] [month] [day of week]\n  *          myMonitor: 'change:someAttribute change:someOtherAttribute'\n  *        }\n  *        If triggeredBy isn't specified, any monitor change will trigger the recipe.\n  * @param [started] {boolean} - Is the recipe started and currently active?\n  */\n  var RecipeProbe = Monitor.RecipeProbe = Probe.extend({\n\n    probeClass: 'Recipe',\n    writableAttributes: [],\n    defaults: {\n      recipeName: '',\n      monitors: {},\n      script: '',\n      autoStart: false,\n      started: false,\n      triggeredBy: null\n    },\n\n    initialize: function(attributes, options){\n      var t = this;\n\n      // Periodic triggers\n      t.interval = null;\n      t.cronJob = null;\n\n      // Precondition test\n      if (_.size(t.get('monitors')) === 0) {\n        logger.error('initialize', 'No monitors defined in the recipe');\n        return;\n      }\n\n      // This is a list of monitors (vs. monitor definitions)\n      t.monitors = {};\n\n      // Auto start, calling the callback when started\n      if (t.get('autoStart')) {\n        options.asyncInit = true;\n        t.start_control({}, options.callback);\n      }\n    },\n\n    release: function() {\n      var t = this,\n          args = arguments;\n      t.stop_control({}, function(){\n        Probe.prototype.release.apply(t, args);\n      });\n    },\n\n    /**\n    * Start the recipe\n    *\n    * This connects to each monitor and sets up the recipe triggers\n    *\n    * @method start_control\n    */\n    start_control: function(params, callback) {\n      var t = this,\n          connectError = false,\n          monitors = t.get('monitors');\n\n      if (t.get('started')) {\n        var err = {code:'RUNNING', msg:'Cannot start - the recipe is already running.'};\n        logger.warn(err);\n        return callback(err);\n      }\n\n      // Called when a monitor has connected\n      var onConnect = function(error) {\n        if (connectError) {return;}\n        if (error) {\n          var err = {code:'CONNECT_ERROR', err: error};\n          connectError = true;\n          logger.error('start', err);\n          return callback(err);\n        }\n        for (var name1 in t.monitors) {\n          if (!t.monitors[name1].isConnected()) {\n            return;\n          }\n        }\n        t.set({started:true});\n        t.connectListeners(true);\n        callback();\n      };\n\n      // Connect all monitors\n      for (var name2 in monitors) {\n        t.monitors[name2] = new Monitor(monitors[name2]);\n        t.monitors[name2].connect(onConnect);\n      }\n\n    },\n\n    /**\n    * Stop the recipe\n    *\n    * This disconnects each monitor\n    *\n    * @method stop_control\n    */\n    stop_control: function(params, callback) {\n      var t = this,\n          disconnectError = false;\n\n      if (!t.get('started')) {\n        var err = {code:'NOT_RUNNING', msg:'The recipe is already stopped.'};\n        logger.warn('precondition', err);\n        return callback(err);\n      }\n\n      // Called when a monitor has disconnected\n      var onDisconnect = function(error) {\n        if (disconnectError) {return;}\n        if (error) {\n          var err = {code:'DISONNECT_ERROR', err: error};\n          disconnectError = true;\n          logger.error('onDisconnect', err);\n          return callback(err);\n        }\n        for (var name1 in t.monitors) {\n          if (t.monitors[name1].isConnected()) {\n            return;\n          }\n        }\n        t.set({started:false});\n        t.compiledScript = null;\n        callback();\n      };\n\n      // Disconnect all monitors\n      t.connectListeners(false);\n      t.context = null;\n      for (var name2 in t.monitors) {\n        t.monitors[name2].disconnect(onDisconnect);\n      }\n    },\n\n    /**\n    * Connect the change listeners\n    *\n    * @private\n    * @method connectListeners\n    */\n    connectListeners: function(connect) {\n      var t = this,\n          triggeredBy = t.get('triggeredBy'),\n          onTrigger = t.onTrigger.bind(t);\n\n      // Default to listen on changes to all monitors\n      if (!triggeredBy) {\n        for (var monitorName in t.monitors) {\n          t.monitors[monitorName][connect ? 'on' : 'off']('change', t.onTrigger, t);\n        }\n        return;\n      }\n\n      // Process the elements in triggeredBy\n      for (var name in triggeredBy) {\n        var value = triggeredBy[name];\n\n        // Construct a new cron job\n        if (name === 'cron') {\n          if (connect) {\n            t.cronJob = new Cron.CronJob(value, onTrigger);\n          }\n          else {\n            if (t.cronJob.initiated) {\n              clearInterval(t.CronJob.timer);\n            }\n            else {\n              setTimeout(function(){clearInterval(t.cronJob.timer);}, 1000);\n            }\n          }\n        }\n\n        // Set a polling interval\n        else if (name === 'interval') {\n          if (connect) {\n            t.interval = setInterval(onTrigger, value);\n          }\n          else {\n            clearInterval(t.interval);\n            t.interval = null;\n          }\n        }\n\n        // Must be a monitor name\n        else {\n          t.monitors[name][connect ? 'on' : 'off'](value, onTrigger);\n        }\n      }\n    },\n\n    /**\n    * Called when a trigger is fired\n    *\n    * @private\n    * @method onTrigger\n    */\n    onTrigger: function() {\n      var t = this;\n      t.run_control({}, function(error){\n        if (error) {\n          logger.error('onTrigger', error);\n        }\n      });\n    },\n\n    /**\n    * Run the recipe script\n    *\n    * This manually runs a started recipe.  The callback is called immediately\n    * after executing the script.\n    *\n    * @method run_control\n    */\n    run_control: function(params, callback) {\n      var t = this,\n          error = null;\n      if (!t.get('started')) {\n        error = {code:'NOT_RUNNING', msg:'Cannot run - recipe not started.'};\n        logger.warn(error);\n        return callback(error);\n      }\n\n      // Name the probe\n      t.name = t.get('probeName') || t.get('id');\n\n      // Build a context to pass onto the script.  The context contains\n      // a console, a logger, and each monitor by name.\n      if (!t.context) {\n        t.context = vm ? vm.createContext({}) : {};\n        t.context.console = console;\n        t.context.logger = Monitor.getLogger('Recipe.run.' + t.name);\n        for (var monitorName in t.monitors) {\n          t.context[monitorName] = t.monitors[monitorName];\n        }\n      }\n\n      // Run the script\n      try {\n        t.run(t.context);\n      } catch(e) {\n        error = \"Error running script: \" + e.toString();\n        logger.error('run_control', error);\n      }\n      callback(error);\n    },\n\n    /**\n    * Execute the recipe.  This is a private method that can be overridden\n    * in derived recipe classes that contain the recipe.\n    *\n    * @private\n    * @method run\n    */\n    run: function(context) {\n      var t = this,\n          script = t.get('script');\n\n      // Run in a VM or exec (if running in a browser)\n      if (vm) {\n        // Compile the script on first run.  This throws an exception if\n        // the script has a problem compiling.\n        if (!t.compiledScript) {\n          t.compiledScript = vm.createScript(script);\n        }\n\n        // Execute the compiled script\n        t.compiledScript.runInContext(context, t.name);\n      }\n      else {\n        // Bring all context variables local, then execute the script\n        eval(t.bringLocal(context));\n        eval(script);\n      }\n    },\n\n    /**\n    * Generate a script that brings context members into local scope\n    *\n    * @private\n    * @method bringLocal\n    */\n    bringLocal: function(context) {\n      var varName,\n          localVars = [];\n      for (varName in context) {\n        localVars.push('var ' + varName + ' = context.' + varName + ';');\n      }\n      return localVars.join('\\n');\n    }\n\n  });\n\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/PollingProbe.js":"// PollingProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._,\n      Cron = Monitor.Cron,\n      Probe = Monitor.Probe,\n      Backbone = Monitor.Backbone;\n\n  // Constants\n  var DEFAULT_POLL_INTERVAL = 1000;\n  var DEFAULT_CRON_PATTERN = \"* * * * * *\";\n\n  /**\n  * ## Base class for probes that require polling to detect and set model changes.\n  *\n  * The probe wakes up every polling interval and executes the poll() method\n  * in the derived class.\n  *\n  * PollingProbes are instantiated with either a polling interval (in milliseconds)\n  * or a cron pattern.  If the polling interval is set, that's what will be used.\n  *\n  * The cronPattern isn't available in browser-side probes.\n  *\n  * To disable polling, set the pollInterval to 0.\n  *\n  * More about cron formats, with examples\n  * <ul>\n  *   <li><a href=\"http://crontab.org/\">http://crontab.org/</a></li>\n  *   <li><a href=\"http://en.wikipedia.org/wiki/Cron\">http://en.wikipedia.org/wiki/Cron</a></li></li>\n  *   <li><a href=\"http://www.adminschoice.com/crontab-quick-reference\">http://www.adminschoice.com/crontab-quick-reference</a></li></li>\n  * </ul>\n  *\n  * @class PollingProbe\n  * @extends Probe\n  * @constructor\n  * @param [initParams] {Object} Probe initialization parameters\n  *     @param [initParams.pollInterval] {Integer} Polling interval in milliseconds. Default: null\n  *     @param [initParams.cronPattern] {String} Crontab syle polling pattern. Default once per second: \"* * * * * *\"\n  *\n  *   The format is: <i>[second] [minute] [hour] [day of month] [month] [day of week]</i>.<br>\n  */\n  var PollingProbe = Monitor.PollingProbe = Probe.extend({\n    defaults: _.extend({}, Probe.prototype.defaults, {\n      pollInterval: null,\n      cronPattern: DEFAULT_CRON_PATTERN\n    }),\n    initialize: function(){\n      var t = this,\n          pollInterval = t.get('pollInterval'),\n          cronPattern = t.get('cronPattern'),\n          poll = function(){t.poll();};\n      Probe.prototype.initialize.apply(t, arguments);\n\n      // Override cron for the default 1-second interval\n      // (this allows the default to work when Cron isn't available)\n      if (pollInterval == null && cronPattern === DEFAULT_CRON_PATTERN) {\n        pollInterval = DEFAULT_POLL_INTERVAL;\n      }\n\n      // Poll once, then set up the interval\n      t.poll();\n      if (pollInterval !== 0) {\n        if (pollInterval) {\n          t.timer = setInterval(poll, pollInterval);\n        } else {\n          if (!Cron) {\n            throw new Error(\"Cron is not available in this client\");\n          }\n          t.cronJob = new Cron.CronJob(cronPattern, poll);\n        }\n      }\n    },\n    release: function(){\n      var t = this, timer = (t.cronJob ? t.cronJob.timer : t.timer);\n      if (t.cronJob && !t.cronJob.initiated) {\n        // If cron isn't initiated we've been asked to shut down within the\n        // first second, and the timer hasn't been set (but will be soon).\n        setTimeout(function(){clearInterval(t.cronJob.timer);}, 1000);\n      } else if (t.timer) {\n        clearInterval(timer);\n      }\n      t.timer = t.cron = null;\n      Probe.prototype.release.apply(t, arguments);\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/StreamProbe.js":"// StreamProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading\n  var Monitor = root.Monitor || require('../Monitor'),\n      Probe = Monitor.Probe,\n      _ = Monitor._;\n\n  // Constants\n  var DEFAULT_BUNDLE_INTERVAL = 1000;\n\n  /**\n  * Base class for probes that stream data\n  *\n  * Offering real time data streaming can result in degraded performance due\n  * to the I/O overhead of sending individual stream elements to remote monitors.\n  *\n  * This class eases that overhead by bundling stream elements, and sending those\n  * bundles in scheduled intervals.  The monitor gets to decide the interval based\n  * on the stream volume, and their needs.\n  *\n  * Derived classes output their stream data as elements of the ```bundle```\n  * attribute.\n  *\n  * A ```sequence``` attribute is incremented sequentially to assure change\n  * events are fired, and to allow clients to insure stream ordering and\n  * completeness.\n  *\n  * @class StreamProbe\n  * @extends Probe\n  * @constructor\n  * @param [initParams] {Object} Probe initialization parameters\n  *     @param [initParams.interval=1000] {Numeric} Number of milliseconds\n  *         to wait between bundles.\n  */\n  var StreamProbe = Monitor.StreamProbe = Probe.extend({\n\n\n    defaults: _.extend({}, Probe.prototype.defaults, {\n      bundle: [],\n      interval: DEFAULT_BUNDLE_INTERVAL,\n      sequence: 0\n    }),\n\n    initialize: function(){\n      var t = this;\n\n      // Initialize parent\n      Probe.prototype.initialize.apply(t, arguments);\n\n      // Moving the interval into an instance variable for performance\n      t.interval = t.get('interval');\n\n      // Set up for the first bundle\n      t.queue = [];\n      t.timer = null;\n      t.lastSendTime = 0;\n    },\n\n    /**\n    * Queue an item in the stream\n    *\n    * This method places the item into the stream and outputs it to the\n    * monitor, or queues it up for the next bundle.\n    *\n    * @method queueItem\n    * @param item {Any} Item to place into the queue\n    */\n    queueItem: function(item) {\n      var t = this,\n          now = Date.now(),\n          msSinceLastSend = now - t.lastSendTime;\n\n      // Queue the item\n      t.queue.push(item);\n\n      // Send the bundle?\n      if (msSinceLastSend > t.interval) {\n        // It's been a while since the last send.  Send it now.\n        t._send();\n      }\n      else {\n        // Start the timer if it's not already running\n        if (!t.timer) {\n          t.timer = setTimeout(function(){\n            t._send();\n          }, t.interval - msSinceLastSend);\n        }\n      }\n    },\n\n    /**\n    * Send the bundle to the montitor\n    *\n    * @private\n    * @method _send\n    */\n    _send: function() {\n      var t = this,\n          now = Date.now();\n\n      // This kicks off the send\n      t.lastSendTime = now;\n      t.set({\n        bundle: t.queue,\n        sequence: t.get('sequence') + 1\n      });\n\n      // Reset\n      t.queue = [];\n      if (t.timer) {\n        clearTimeout(t.timer);\n        t.timer = null;\n      }\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/InspectProbe.js":"// InspectProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n\n/* This class is evil.  You probably shouldn't use it.  Or drink.  Or drink while using it. */\n/*jslint evil: true */\n\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._,\n      logger = Monitor.getLogger('InspectProbe'),\n      Backbone = Monitor.Backbone,\n      PollingProbe = Monitor.PollingProbe;\n\n  // Constants\n  var DEFAULT_DEPTH = 2;\n\n  /**\n  * Inspect and manipulate variables on the monitored server.\n  *\n  * This class monitors the variable specified by the key.\n  *\n  * The key is evaluated to determine the variable to monitor, so it may\n  * be a complex key starting at global scope.  If the key isn't\n  * specified, it monitors all variables in the global scope.\n  *\n  * If the key points to an object of type Backbone.Model, this probe\n  * will update the value in real time, triggered on the *change* event.\n  * Otherwise it will update the value as it notices changes, while polling\n  * on the specified polling interval (default: 1 second).\n  *\n  * @class InspectProbe\n  * @extends PollingProbe\n  * @constructor\n  * @param [initParams] - Initialization parameters\n  *     @param [initParams.key=null] {String} A global variable name or expression\n  *     @param [initParams.depth=2] {Integer} If the key points to an object, this\n  *       is the depth to traverse the object for changes.  Default=2, or 1 if\n  *       key='window'.\n  *     @param [initParams.pollInterval] {Integer} (from <a href=\"PollingProbe.html\">PollingProbe</a>) Polling interval in milliseconds. Default: null\n  *     @param [initParams.cronPattern] {String} (from <a href=\"PollingProbe.html\">PollingProbe</a>) Crontab syle polling pattern. Default once per second: \"* * * * * *\"\n  * @param model - Monitor data model elements\n  *     @param model.value - The value of the element being inspected\n  *     @param model.isModel - Is the value a Backbone.Model?\n  */\n  var InspectProbe = Monitor.InspectProbe = PollingProbe.extend({\n\n    // These are required for Probes\n    probeClass: 'Inspect',\n    writableAttributes: ['value'],\n\n    initialize: function(initParams){\n      var t = this;\n\n      // Get the global object if the key isn't specified\n      t.key = initParams.key;\n      if (typeof initParams.key === 'undefined') {\n        t.key = typeof window === 'undefined' ? 'global' : 'window';\n      }\n\n      // Get a good depth default.  Default unless key = window.\n      if (typeof initParams.depth === 'undefined') {\n        if (!initParams.key && t.key === 'window') {\n          t.depth = 1;\n        } else {\n          t.depth = DEFAULT_DEPTH;\n        }\n      } else {\n        t.depth = initParams.depth;\n      }\n\n      // Evaluate the expression to see if it's a Backbone.Model\n      // This will throw an exception if the key is a bad expression\n      t.value = t._evaluate(t.key);\n      t.isModel = t.value instanceof Backbone.Model;\n\n      // Set the initial values\n      t.set({\n        value: Monitor.deepCopy(t.value, t.depth),\n        isModel: t.isModel\n      });\n\n      // Watch for backbone model changes, or initialize the polling probe\n      if (t.isModel) {\n        t.value.on('change', t.poll, t);\n      } else {\n        PollingProbe.prototype.initialize.apply(t, arguments);\n      }\n    },\n\n    /**\n    * Remotely set the inspected variable's value\n    *\n    * @method set_control\n    * @param attrs {Object} Name/Value attributes to set.  All must be writable.\n    * @param callback {Function(error)} Called when the attributes are set or error\n    */\n    set_control: function(attrs, callback) {\n      var t = this;\n\n      // Value is the only thing to set\n      if (typeof attrs.value === 'undefined') {\n        return callback({code:'NO_VALUE'});\n      }\n\n      // Set the model elements.  These cause change events to fire\n      if (t.isModel) {\n        t.value.set(attrs.value);\n      }\n      else {\n        // Set the variable directly\n        var jsonValue = JSON.stringify(attrs.value);\n        t._evaluate(t.key + ' = ' + jsonValue);\n        t.set('value', attrs.value);\n      }\n      return callback();\n    },\n\n    // Stop watching for change events or polling\n    release: function() {\n      var t = this;\n      if (t.isModel) {\n        t.value.off('change', t.poll, t);\n      } else {\n        PollingProbe.prototype.release.apply(t, arguments);\n      }\n    },\n\n    /**\n    * Evaluate an expression, returning the depth-limited results\n    *\n    * @method eval_control\n    * @param expression {String} Expression to evaluate\n    * @param [depth=2] {Integer} Depth of the object to return\n    * @return value {Mixed} Returns the depth-limited value\n    */\n    eval_control: function(expression, depth){\n      var t = this;\n\n      // Determine a default depth\n      depth = typeof depth === 'undefined' ? DEFAULT_DEPTH : depth;\n\n      // Get the raw value\n      var value = t._evaluate(expression);\n\n      // Return the depth limited results\n      return Monitor.deepCopy(value, depth);\n    },\n\n    /**\n    * Evaluate an expression, returning the raw results\n    *\n    * @protected\n    * @method _evaluate\n    * @param expression {String} Expression to evaluate\n    * @return value {Mixed} Returns the expression value\n    */\n    _evaluate: function(expression){\n      var t = this,\n          value = null;\n\n      // Evaluate the expression\n      try {\n        value = eval(expression);\n      } catch (e) {\n        var err = 'Unable to evaluate expression: \"' + expression + '\"';\n        logger.error('evaluate', err);\n        throw new Error(err);\n      }\n\n      // Return the value\n      return value;\n    },\n\n    /**\n    * Poll for changes in the evaluation\n    *\n    * @method poll\n    */\n    poll: function() {\n      var t = this,\n          newValue = t.eval_control(t.key, t.depth);\n\n      // Set the new value if it has changed from the current value\n      if (!_.isEqual(newValue, t.get('value'))) {\n        t.set({value: newValue});\n      }\n    }\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/StatProbe.js":"// StatProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root) {\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._,\n      StreamProbe = Monitor.StreamProbe,\n      Stat = Monitor.Stat;\n\n  // Constants\n  var DEFAULT_PATTERN = '*';\n\n  /**\n  * Remote application statistics monitoring\n  *\n  * This probe forwards application statistics to the monitor.\n  *\n  * @class StatProbe\n  * @extends StreamProbe\n  * @constructor\n  * @param [initParams] {Object} Probe initialization parameters\n  *     @param [initParams.pattern=*] {String} Stat name pattern to monitor (see <a href=\"Stat.html\">Stat</a>)\n  *     @param [initParams.interval=1000] {Numeric} Queue interval (see <a href=\"StreamProbe.html\">StreamProbe</a>)\n  * @param model {Object} Monitor data model elements\n  *     @param model.bundle {Stat array} Array of Stat elements.\n  *         @param model.bundle.timestamp {String} Timestamp of the stat entry\n  *         @param model.bundle.module {String} Stat module\n  *         @param model.bundle.name {String} Stat name\n  *         @param model.bundle.value {Numeric} Stat value\n  *         @param model.bundle.type {String} 'c'ounter, 'g'ague, or 'ms'timer\n  *     @param model.sequence {Integer} A numeric incrementer causing a change event\n  */\n  var StatProbe = Monitor.StatProbe = StreamProbe.extend({\n\n    probeClass: 'Stat',\n\n    defaults: _.extend({}, StreamProbe.prototype.defaults, {\n      pattern: DEFAULT_PATTERN\n    }),\n\n    initialize: function(){\n      var t = this;\n\n      // Call parent constructor\n      StreamProbe.prototype.initialize.apply(t, arguments);\n\n      // The watcher just forwards all args to queueItem as an array\n      t.watcher = function() {\n        // Add timestamp as the first element\n        var logElems = _.toArray(arguments);\n        logElems.splice(0,0,JSON.stringify(new Date()).substr(1,24));\n        t.queueItem.call(t, logElems);\n      };\n      Stat.on(t.get('pattern'), t.watcher);\n    },\n\n    release: function() {\n      var t = this;\n      Stat.off(t.get('pattern'), t.watcher);\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/LogProbe.js":"// LogProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root) {\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._,\n      StreamProbe = Monitor.StreamProbe,\n      Log = Monitor.Log;\n\n  // Constants\n  var DEFAULT_PATTERN = '*';\n\n  /**\n  * Remote application log monitoring\n  *\n  * This probe forwards application logs to the monitor.\n  *\n  * @class LogProbe\n  * @extends StreamProbe\n  * @constructor\n  * @param [initParams] {Object} Probe initialization parameters\n  *     @param [initParams.pattern=*] {String} Log name pattern to monitor (see <a href=\"Log.html\">Log</a>)\n  *     @param [initParams.interval=1000] {Numeric} Queue interval (see <a href=\"StreamProbe.html\">StreamProbe</a>)\n  * @param model {Object} Monitor data model elements\n  *     @param model.bundle {Log array} Array of Log elements.\n  *         @param model.bundle.timestamp {String} Timestamp of the log statement\n  *         @param model.bundle.logType {String} Log type (error, info, etc)\n  *         @param model.bundle.module {String} Module that emitted the log\n  *         @param model.bundle.name {String} Log entry name\n  *         @param model.bundle.args {any[]} Arguments to the log statement\n  *     @param model.sequence {Integer} A numeric incrementer causing a change event\n  */\n  var LogProbe = Monitor.LogProbe = StreamProbe.extend({\n\n    probeClass: 'Log',\n\n    defaults: _.extend({}, StreamProbe.prototype.defaults, {\n      pattern: DEFAULT_PATTERN\n    }),\n\n    initialize: function(){\n      var t = this;\n\n      // Call parent constructor\n      StreamProbe.prototype.initialize.apply(t, arguments);\n\n      // The watcher just forwards all args to queueItem as an array\n      t.watcher = function() {\n        // Add timestamp as the first element\n        var logElems = _.toArray(arguments);\n        logElems.splice(0,0,JSON.stringify(new Date()).substr(1,24));\n        t.queueItem.call(t, logElems);\n      };\n      Log.on(t.get('pattern'), t.watcher);\n    },\n\n    release: function() {\n      var t = this;\n      Log.off(t.get('pattern'), t.watcher);\n    }\n\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/FileProbe.js":"// FileProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._,\n      Probe = Monitor.Probe,\n      FS = require('fs'),\n      Path = require('path');\n\n  // This must be set using setRootPath() before the probe will operate\n  var ROOT_PATH = null;\n  \n  // TODO: Implement streaming - possibly with the 10.x streaming interface?\n  // http://blog.strongloop.com/practical-examples-of-the-new-node-js-streams-api/?goback=%2Egde_3208061_member_245121234\n\n  /**\n  * Baseline Probe Classes\n  *\n  * The probes in this module offer baseline functionality, and provide examples for building custom probes.\n  *\n  * @module Probes\n  */\n\n  /**\n  * Probe for monitoring a file on the O/S.\n  *\n  * This probe monitors a file for changes.  It can either contain the full file\n  * contents, or the most recent file changes.\n  *\n  * For security purposes, this probe is disabled by default.  The application\n  * server must set the root directory path using ```setRootPath()``` before\n  * the probe will operate.\n  *\n  * To enable FileProbe on the server:\n  *\n  *     // Enable the File probe under the user home directory\n  *     var Monitor = require('monitor');\n  *     Monitor.FileProbe.setRootPath('/home/public');\n  *\n  * This class also contains server-side utility methods for file and\n  * directory manipulation.\n  *\n  * Using the FileProbe (client or server):\n  *\n  *     // Watch the template for changes\n  *     var indexTemplate = new Monitor({\n  *       probeClass: 'File',\n  *       initParams: {\n  *         path: 'templates/index.html'\n  *       }\n  *     });\n  *     indexTemplate.connect(function(error) {\n  *       console.log(\"Connected\");\n  *     });\n  *\n  * Once connected, the ```text``` field of ```indexTemplate``` will be set to\n  * the file contents, and the ```change``` listener will fire whenever the\n  * server detects a change in the template file.\n  *\n  * @class FileProbe\n  * @extends Probe\n  * @constructor\n  * @param initParams {Object} Remote initialization parameters\n  *     @param initParams.path {String} Path to the file beneath the server-specified root path.\n  *     @param [initParams.tail=false] {Boolean} false:text contains current file content, true: text contains last changes.\n  * @param model {Object} Monitor data model elements\n  *     @param model.text {String} Full file contents, or last file changes.\n  *     @param model.error {String} File read errors.\n  */\n  var FileProbe = Monitor.FileProbe = Probe.extend({\n\n    probeClass: 'File',\n    defaults: {path:'', tail:false, text:''},\n\n    initialize: function(attributes, options){\n      var t = this;\n      Probe.prototype.initialize.apply(t, arguments);\n\n      // Disable the probe if the root path hasn't been set\n      if (!ROOT_PATH) {\n        throw new Error('File probe has not been enabled on this server.');\n      }\n\n      // Don't allow a path above the root path\n      t.fullPath = Path.join(ROOT_PATH, t.get('path'));\n      if (t.fullPath.indexOf(ROOT_PATH) !== 0) {\n        throw new Error('Invalid file path');\n      }\n\n      // Assume callback responsibility.\n      options.asyncInit = true;\n      var callback = options.callback;\n\n      // Set up for reading or tailing\n      if (t.get('tail')) {\n\n        //TODO: Implement tail\n        return callback({code:'UNDER_CONSTRUCTION', msg:'Tail functionality not implemented.'});\n\n      } else {\n\n        // Build the function to call on initial load and subsequent change\n        t.onLoad = function(error, newContent) {\n          var firstLoad = (callback !== null);\n          t.set({error: error, text: newContent}, {silent:firstLoad});\n\n          // Call the init callback on first load\n          if (firstLoad) {\n            callback(error);\n            callback = null;\n          }\n        };\n\n        // Load and watch the file\n        var watcherOpts = {\n          preload: true,\n          persistent: true\n        };\n        t.watcher = FileProbe.watchLoad(t.fullPath, watcherOpts, t.onLoad);\n      }\n    },\n\n    release: function() {\n      var t = this;\n      if (t.watcher) {\n        t.watcher.close();\n      }\n      Probe.prototype.release.apply(t, arguments);\n    }\n\n  });\n\n  /**\n  * Build a backwards compatible file change watcher\n  *\n  * The Node.js\n  * <a href=\"http://nodejs.org/api/all.html#all_fs_watch_filename_options_listener\">```fs.watch```</a>\n  * functionality was introduced in version 0.6.x.  This method builds a watcher\n  * object that uses the new funcitonality, and degrades to the polling style\n  * ``fs.watchFile`` functionality if running with node.js that doesn't have\n  * ```fs.watch```.\n  *\n  * The provided callback is only fired if the file has changed.\n  *\n  * When done watching, make sure to call the ```close()``` method of the\n  * returned object to release resources consumed by file watching.\n  *\n  * @static\n  * @method watch\n  * @param path {String} Path to the file\n  * @param [options] {Object} File watch options\n  *     @param [options.persistent=false] {Boolean} File encoding type.\n  *     @param [options.pollStyle=false] {Boolean} Use the older polling-style watchFile.\n  *     @param [options.interval=10] {Integer} Polling interval (if pollStyle=true)\n  * @param callback {Function (event)} Function called on file change.\n  *     @param callabck.event {String} One of 'change' or 'rename' (delete = 'rename')\n  * @return {Object} An object that contains a ```close()``` method to call when\n  *     done watching.\n  */\n  FileProbe.watch = function(path, options, callback) {\n\n    // Process arguments\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    var defaultOpts = {persistent:false, pollStyle:false, interval:10};\n    var opts = _.extend({}, defaultOpts, options);\n\n    // Use fs.watch or fs.watchFile\n    var watcher = null;\n    if (FS.watch && !opts.pollStyle) {\n      // Latest watch method\n      try {\n        watcher = FS.watch(path, opts, function(event, filename) {\n          callback(event);\n        });\n      } catch (e) {\n        // Return a mock watcher.  The callback will be called on error.\n        watcher = {\n          close: function(){}\n        };\n      }\n    }\n    else {\n      FS.watchFile(path, opts, function(curr, prev) {\n        // Detect file deletion\n        if (curr.nlink === 0) {\n          return callback('rename');\n        }\n        if (curr.mtime.getTime() === prev.mtime.getTime()) {\n          return;\n        }\n        return callback('change');\n      });\n    }\n\n    // Return the object for closing\n    return {\n      close: function() {\n        if (watcher) {\n          watcher.close();\n        } else {\n          FS.unwatchFile(path);\n        }\n      }\n    };\n  };\n\n  /**\n  * Watch a file for changes and reload the content on change\n  *\n  * This method accepts a callback function that is invoked whenever the file\n  * contents have changed.  If preload is requested, the callback is also called\n  * on the initial file contents.\n  *\n  *     // Monitor the homePage.html template\n  *     var FileProbe = Monitor.FileProbe;\n  *     var path = __dirname + \"/templates/homePage.html\";\n  *     var options = {preload:true};\n  *     var homePageWatcher = FileProbe.watchLoad(path, options, function(error, content) {\n  *       console.log(\"Home page template: \" + content)\n  *     });\n  *\n  * This uses the Node.js\n  * <a href=\"http://nodejs.org/api/all.html#all_fs_watch_filename_options_listener\">```fs.watch```</a>\n  * functionality if available, or the older polling mechanism if running on\n  * a pre-0.6.x version of Node.js.\n  *\n  * When done watching, call the ```close()``` method of the returned watcher\n  * object.  This releases all resources associated with file watching.\n  *\n  *     // Stop watching the homePage template\n  *     homePageWatcher.close();\n  *\n  * @static\n  * @method watchLoad\n  * @param path {String} Path to the file\n  * @param [options] {Object} File watch options\n  *     @param options.encoding='utf8' {String} File encoding type.\n  *     @param options.preload=false {boolean} Preload the contents, calling the callback when preloaded.\n  *     @param options.persistent=false {boolean} Persistent file watching?\n  * @param callback {Function (error, content)} Function called on file change (or error), and on preload if requested.\n  * @return {Object} An object that contains a ```close()``` method to call when\n  *     done watching.\n  */\n  FileProbe.watchLoad = function(path, options, callback) {\n\n    // Process arguments\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    var defaultOpts = {encoding:'utf8', preload:false, persistent:false};\n    var opts = _.extend({}, defaultOpts, options);\n\n    // Build the function to call when the file changes\n    var onFileChange = function() {\n      FS.readFile(path, options.encoding, function(err, text) {\n        if (err) {\n          // Forward the error\n          return callback(err);\n        }\n        // Success\n        callback(null, text.toString());\n      });\n    };\n\n    // Read initial file contents if requested\n    if (options.preload) {\n      onFileChange();\n    }\n\n    // Connect the file watcher\n    return FileProbe.watch(path, options, onFileChange);\n  };\n\n  /**\n  * Tail a file\n  *\n  * @static\n  * @method tail\n  * @param path {String} Path to the file\n  * @param [options] {Object} File watch options\n  *     @param options.encoding=UTF8 {String} File encoding type.\n  * @param callback {Function (content)} Function called on change\n  * @return {Object} An object that contains a ```close()``` method to call when\n  *     done tailing.\n  */\n  FileProbe.tail = function() {\n    var t = this, path = t.fullPath;\n\n  };\n\n  /**\n  * Create a directory recursively\n  *\n  * This makes a directory and all nodes above it that need creating.\n  *\n  * @static\n  * @method mkdir_r\n  * @param dirname {String} Full directory path to be made\n  * @param [mode=0777] {Object} Directory creation mode (see fs.mkdir)\n  * @param [callback] {Function(error)} Called when complete, with possible error.\n  */\n  FileProbe.mkdir_r = function(dirname, mode, callback) {\n\n    // Optional arguments\n    if (typeof mode === 'function') {\n      callback = mode;\n      mode = null;\n    }\n    callback = callback || function(){};\n    mode = mode || '777';\n\n    // First attempt\n    FS.mkdir(dirname, mode, function(err1) {\n\n      // Success\n      if (!err1 || err1.code === 'EEXIST') {\n        return callback(null);\n      }\n\n      // Failure.  Try making parent.\n      var parent = Path.dirname(dirname);\n      FileProbe.mkdir_r(parent, mode, function(err2) {\n\n        // Successful parent create.  Try child one more time.\n        if (!err2) {\n          return FS.mkdir(dirname, mode, callback);\n        }\n\n        // Couldn't make parent.\n        callback(err2);\n      });\n    });\n  };\n\n  /**\n  * Remove a file or directory recursively\n  *\n  * This is equivalent to shell rm -rf {filepath or dirpath}.\n  *\n  * @static\n  * @method rm_rf\n  * @param path {String} Path to a directory or file to remove\n  * @param callback {function(error)} Function to call when done, with possible error.\n  */\n  FileProbe.rm_rf = function(path, callback) {\n\n    // Get the file/dir status\n    callback = callback || function(){};\n    var stats = FS.lstat(path, function(err, stats){\n      if (err) {\n        return callback(err);\n      }\n\n      // If it's a directory, remove all files then the directory\n      if (stats.isDirectory()) {\n\n        // Read all files in the directory\n        FS.readdir(path, function(err1, files) {\n          if (err1) {\n            return callback(err1);\n          }\n\n          // Done if no files\n          if (files.length === 0) {\n            return callback();\n          }\n\n          // Remove all files asynchronously\n          var numLeft = files.length;\n          var lastError = null;\n          files.forEach(function (filename) {\n            FileProbe.rm_rf(Path.join(path, filename), function(err2){\n              lastError = err2 || lastError;\n              if (--numLeft === 0) {\n                if (lastError) {\n                  return callback(lastError);\n                }\n                // Remove the original directory\n                FS.rmdir(path, callback);\n              }\n            });\n          });\n        });\n      }\n\n      // Directly remove if it's any non-directory type\n      else {\n        return FS.unlink(path, callback);\n      }\n\n    });\n  };\n\n  /**\n  * Set the server root path for the file probe\n  *\n  * For security purposes, this must be set server-side before the File probe\n  * will operate.  It will not accept any changes once set.\n  *\n  * @static\n  * @method setRootPath\n  * @param rootPath {String} A path to the root directory for the FilePath probe\n  */\n  FileProbe.setRootPath = function(rootPath) {\n    var normalized = Path.normalize(rootPath);\n    if (ROOT_PATH && ROOT_PATH !== normalized) {\n      throw new Error('Cannot change the File probe root path once set.');\n    }\n    ROOT_PATH = normalized;\n  };\n\n  /**\n  * Get the current root path.\n  *\n  * As a static method, this is only available on the server running the probe.\n  * For security purposes, this is not exposed in the FileProbe data model.\n  *\n  * @static\n  * @method getRootPath\n  * @return {String} The path to the root directory for the FilePath probe\n  */\n  FileProbe.getRootPath = function() {\n    return ROOT_PATH;\n  };\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/ReplProbe.js":"// ReplProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._,\n      Probe = Monitor.Probe,\n      REPL = require('repl'),\n      Stream = require('stream'),\n      util = require('util'),\n      events = require('events'),\n      ChildProcess = require('child_process');\n\n  // Statics\n  var CONSOLE_PROMPT = '> ';\n  var NEW_REPL = (typeof REPL.disableColors === 'undefined');\n\n  /**\n  * A probe based Read-Execute-Print-Loop console for node.js processes\n  *\n  * @class ReplProbe\n  * @extends Probe\n  * @constructor\n  * @param initParams {Object} Probe initialization parameters\n  *     @param initParams.uniqueInstance - Usually specified to obtain a unique REPL probe instance\n  * @param model {Object} Monitor data model elements\n  *     @param model.output {String} Last (current) REPL output line\n  *     @param model.sequence {Integer} Increasing sequence number - to enforce unique line output\n  */\n  var ReplProbe = Monitor.ReplProbe = Probe.extend({\n\n    probeClass: 'Repl',\n    description: 'A socket.io based Read-Execute-Print-Loop console for node.js processes.',\n    defaults: {\n      // This assures output events are sent, even if the\n      // data is the same as the prior output.\n      sequence: 0,\n      output: ''\n    },\n\n    initialize: function(attributes, options){\n      var t = this;\n      Probe.prototype.initialize.apply(t, arguments);\n\n      // Don't send change events before connected\n      process.nextTick(function(){\n        t.stream = new ReplStream(t);\n        if (NEW_REPL) {\n          t.repl = require('repl').start({\n            prompt: CONSOLE_PROMPT,\n            input: t.stream,\n            output: t.stream\n          });\n        } else {\n          t.repl = REPL.start(CONSOLE_PROMPT, t.stream);\n        }\n        t.htmlConsole = new HtmlConsole(t);\n        t.shellCmd = null;\n        t.repl.context.console = t.htmlConsole;\n      });\n    },\n\n    /**\n    * Send output to the terminal\n    *\n    * This forces the change event even if the last output is the same\n    * as this output.\n    *\n    * @protected\n    * @method output\n    * @param str {String} String to output to the repl console\n    */\n    _output: function(str) {\n      var t = this;\n      t.set({\n        output: str,\n        sequence: t.get('sequence') + 1\n      });\n    },\n\n    /**\n    * Release any resources consumed by this probe.\n    *\n    * Stop the REPL console.  Consoles live 1-1 with a UI counterpart, so stop\n    * requests exit the underlying repl console.  If the probe is re-started it\n    * will get a new repl stream and console.\n    *\n    * @method release\n    */\n    release: function(){\n      var t = this;\n      t.stream = null;\n      t.repl = null;\n    },\n\n    /**\n    * Process an autocomplete request from the client\n    *\n    * @method autocomplete\n    * @param {Object} params Named parameters\n    * @param {Function(error, returnParams)} callback Callback function\n    */\n    autocomplete_control: function(params, callback) {\n      var t = this;\n      if (typeof(params) !== 'string' || params.length < 1) {\n        callback(\"Autocomplete paramter must be a nonzero string\");\n      }\n\n      // Forward to the completion mechanism if it can be completed\n      if (params.substr(-1).match(/([0-9])|([a-z])|([A-Z])|([_])/)) {\n        t.repl.complete(params, callback);\n      } else {\n        // Return a no-op autocomplete\n        callback(null, [[],'']);\n      }\n    },\n\n    /**\n    * Handle user input from the console line\n    *\n    * @method input\n    * @param {Object} params Named parameters\n    * @param {Function(error, returnParams)} callback Callback function\n    */\n    input_control: function(params, callback) {\n      var t = this;\n      if (params === '.break' && t.shellCmd) {\n        t.shellCmd.kill();\n      }\n      if (NEW_REPL) {\n        t.stream.emit('data', params + \"\\n\");\n      } else {\n        t.stream.emit('data', params);\n      }\n      return callback(null);\n    },\n\n    /**\n    * Execute a shell command\n    *\n    * @method sh\n    * @param {Object} params Named parameters\n    * @param {Function(error, returnParams)} callback Callback function\n    */\n    sh_control: function(params, callback) {\n      var t = this;\n      return callback(null, t._runShellCmd(params));\n    },\n\n    /**\n    * Run a shell command and emit the output to the browser.\n    *\n    * @private\n    * @method _runShellCmd\n    * @param {String} command - The shell command to invoke\n    */\n    _runShellCmd: function(command) {\n      var t = this;\n      t.shellCmd = ChildProcess.exec(command, function(err, stdout, stderr) {\n        if (err) {\n          var outstr = 'exit';\n          if (err.code) {\n            outstr += ' (' + err.code + ')';\n          }\n          if (err.signal) {\n            outstr += ' ' + err.signal;\n          }\n          t._output(outstr);\n          return null;\n        }\n        if (stdout.length) {\n          t._output(stdout);\n        }\n        if (stderr.length) {\n          t._output(stderr);\n        }\n        t.shellCmd = null;\n        t._output(CONSOLE_PROMPT);\n      });\n      return null;\n    }\n\n  });\n\n  // Define an internal stream class for the probe\n  var ReplStream = function(probe){\n    var t = this;\n    t.probe = probe;\n    events.EventEmitter.call(t);\n    if (t.setEncoding) {\n      t.setEncoding('utf8');\n    }\n  };\n  util.inherits(ReplStream, events.EventEmitter);\n  // util.inherits(ReplStream, require('stream'));\n  ReplStream.prototype.readable = true;\n  ReplStream.prototype.writable = true;\n  ['pause','resume','destroySoon','pipe', 'end']\n    .forEach(function(fnName){\n      ReplStream.prototype[fnName] = function(){\n        console.log(\"REPL Stream function unexpected: \" + fnName);\n      };\n    });\n  ['resume']\n    .forEach(function(fnName){\n      ReplStream.prototype[fnName] = function(){\n        // Handled\n      };\n    });\n  ReplStream.prototype.write = function(data) {\n    var t = this;\n    t.probe._output(data);\n  };\n  ReplStream.prototype.destroy = function(data) {\n    var t = this;\n  console.log(\"REPL stream destroy \" + t.probe.get('id'));\n    t.probe.stop();\n  };\n\n  // Define format if it's not in util.\n  var formatRegExp = /%[sdj]/g;\n  var format = util.format || function (f) {\n    if (typeof f !== 'string') {\n      var objects = [];\n      for (var i = 0; i < arguments.length; i++) {\n        objects.push(util.inspect(arguments[i]));\n      }\n      return objects.join(' ');\n    }\n    var j = 1;\n    var args = arguments;\n    var str = String(f).replace(formatRegExp, function(x) {\n      switch (x) {\n        case '%s': return String(args[j++]);\n        case '%d': return Number(args[j++]);\n        case '%j': return JSON.stringify(args[j++]);\n        default:\n          return x;\n      }\n    });\n    for (var len = args.length, x = args[j]; j < len; x = args[++j]) {\n      if (x === null || typeof x !== 'object') {\n        str += ' ' + x;\n      } else {\n        str += ' ' + util.inspect(x);\n      }\n    }\n    return str;\n  };\n\n  // Re-define the console so it goes to the HTML window\n  var HtmlConsole = function(probe){\n    this.probe = probe;\n  };\n  HtmlConsole.prototype.log = function(msg) {\n    this.probe._output(format.apply(this, arguments));\n  };\n  HtmlConsole.prototype.info = HtmlConsole.prototype.log;\n  HtmlConsole.prototype.warn = HtmlConsole.prototype.log;\n  HtmlConsole.prototype.error = HtmlConsole.prototype.log;\n  HtmlConsole.prototype.dir = function(object) {\n    this.probe._output(util.inspect(object));\n  };\n  var times = {};\n  HtmlConsole.prototype.time = function(label) {\n    times[label] = Date.now();\n  };\n  HtmlConsole.prototype.timeEnd = function(label) {\n    var duration = Date.now() - times[label];\n    this.log('%s: %dms', label, duration);\n  };\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/ProcessProbe.js":"// ProcessProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading - this runs server-side only\n  var util = require('util'), OS = require('os'),\n      Monitor = root.Monitor || require('../Monitor'), _ = Monitor._,\n      logger = Monitor.getLogger('ProcessProbe'),\n      PollingProbe = Monitor.PollingProbe;\n\n  /**\n  * Probe for attaining process and O/S information\n  *\n  * @class ProcessProbe\n  * @extends PollingProbe\n  * @constructor\n  * @param [initParams] {Object} Probe initialization parameters (from PollingProbe)\n  *     @param [initParams.pollInterval] {Integer} Polling interval in milliseconds. Default: null\n  *     @param [initParams.cronPattern] {String} Crontab syle polling pattern. Default once per second: \"* * * * * *\"\n  * @param model {Object} Monitor data model elements\n  *     @param model.platform {String} O/S Platform\n  *     @param model.version {String} Node.js compiled-in version\n  *     @param model.installPrefix {String} Node.js installation directory\n  *     @param model.title {String} The current process title (as reported in ps)\n  *     @param model.execPath {String} The path to the current node.js executable\n  *     @param model.argv {Array(String)} Arguments passed on the command line to this process\n  *     @param model.env {Object} Current environment (inherited)\n  *     @param model.cwd {String} Current working directory\n  *     @param model.uptime {Integer} Number of seconds the process has been up (if available)\n  *     @param model.versions {String} Versions of V8 and dependent libraries (if available)\n  *     @param model.arch {String} Processor architecture (if available)\n  *     @param model.gid {Integer} Process group ID\n  *     @param model.uid {Integer} Process user ID\n  *     @param model.pid {Integer} Unique process ID\n  *     @param model.umask {Integer} The process file mode creation mask\n  *     @param model.memoryUsage {Object} An object describing memory usage of the node.js process\n  *         @param model.memoryUsage.rss {Integer} As defined by process.memoryUsage\n  *         @param model.memoryUsage.vsize {Integer} As defined by process.memoryUsage\n  *         @param model.memoryUsage.heapTotal {Integer} As defined by process.memoryUsage\n  *         @param model.memoryUsage.heapUsed {Integer} As defined by process.memoryUsage\n  *     @param model.os {Object} An object containing O/S information\n  *         @param model.os.hostname {String} Name of the host operating system\n  *         @param model.os.type {String} Operating system type\n  *         @param model.os.release {String} O/S Release version\n  *         @param model.os.uptime {String} O/S Uptime in seconds\n  *         @param model.os.loadavg {Array(Number)} An array containing the 1, 5, and 15 minute load averages\n  *         @param model.os.freemem {Integer} Free O/S memory (in bytes)\n  *         @param model.os.totalmem {Integer} Total O/S memory capacity (in bytes)\n  *         @param model.os.cpus {Array(Object)} An array of objects containing information about each CPU/core installed\n  */\n  var ProcessProbe = Monitor.ProcessProbe = PollingProbe.extend({\n\n    // These are required for Probes\n    probeClass: 'Process',\n\n    /* not required\n    initialize: function(){\n      var t = this;\n      PollingProbe.prototype.initialize.apply(t, arguments);\n      ...\n    },\n    release: function() {\n      var t = this;\n      PollingProbe.prototype.release.apply(t, arguments);\n      ... // release any resources held\n    })\n    */\n\n    /**\n    * Poll the probe for changes\n    *\n    * This method is called by the parent <a href=\"PollingProbe.html\">PollingProbe</a> on the interval specified by the client <a href=\"Monitor.html\">Monitor</a>.\n    *\n    * It polls for process information, and updates the data model with any changes.\n    *\n    * @method poll\n    */\n    poll: function() {\n      var t = this,\n      attrs = _.extend({\n        platform: process.platform,\n        version: process.version,\n        installPrefix: process.installPrefix,\n        title: process.title,\n        execPath: process.execPath,\n        argv: process.argv,\n        env: process.env,\n        cwd: process.cwd(),\n        gid: process.getgid ? process.getgid() : 0,\n        uid: process.getuid ? process.getuid() : 0,\n        pid: process.pid,\n        umask: process.umask(),\n        hostname: OS.hostname(),\n        type: OS.type(),\n        release: OS.release(),\n        osUptime: OS.uptime(),\n        loadavg: OS.loadavg(),\n        freemem: OS.freemem(),\n        totalmem: OS.totalmem(),\n        cpus: OS.cpus()\n      }, process.memoryUsage());\n      if (process.uptime) {attrs.uptime = process.uptime();}\n      if (process.versions) {attrs.versions = process.versions;}\n      if (process.arch) {attrs.arch = process.arch;}\n      t.set(attrs);\n    }\n  });\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/SyncProbe.js":"// SyncProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      _ = Monitor._, Probe = Monitor.Probe;\n\n  /**\n  * Probe for exposing backbone data models from server-side persistence\n  *\n  * This probe is used by the client-side <a href=\"Sync.html\">Sync</a> class\n  * to connect a local backbone model with server-side storage.\n  *\n  * It delegates to a specialized SyncProbe defined by the server for the\n  * specific data class.  For example, the server may determine that one class\n  * type uses FileSyncProbe, and another class uses a different persistence\n  * mechanism.\n  *\n  * For security purposes, the server must <a href=\"SyncProbe.html#property_Config\">configure</a> specific SyncProbes for\n  * classes, or a default sync probe before this will operate.\n  *\n  * @class SyncProbe\n  * @extends Probe\n  * @constructor\n  * @param className {String} Name of the class to synchronize with\n  * @param [modelId] {String} Id of the data model for live synchronization\n  *   If not set, a non-live probe is set up for control access only.\n  * @param [model] {Object} If this is a liveSync probe, this contains\n  *   the attributes of the current model object.\n  */\n  var SyncProbe = Monitor.SyncProbe = Probe.extend({\n\n    probeClass: 'Sync',\n    defaults: {\n      className: null,\n      modelId: null,\n      model: null\n    },\n\n    initialize: function(attributes, options){\n      var t = this;\n      Probe.prototype.initialize.apply(t, arguments);\n\n      // Determine the probe name based on the class, and coerce this\n      // object into one of those by copying all prototype methods.\n      var className = t.get('className'),\n          config = SyncProbe.Config,\n          probeClassName = config.classMap[className] || config.defaultProbe,\n          probeClass = SyncProbe[probeClassName];\n      _.each(_.functions(probeClass.prototype), function(methodName) {\n        t[methodName] = probeClass.prototype[methodName];\n      });\n      t.probeClass = probeClass.prototype.probeClass;\n\n      // Forward class initialization to the coerced initialize method\n      return t.initialize.apply(t, arguments);\n    },\n\n    release: function() {\n      var t = this;\n      Probe.prototype.release.apply(t, arguments);\n    },\n\n    /**\n    * Create and save a new instance of the class into storage\n    *\n    * This probe control requests a new instance of a data model to be\n    * persisted onto storage.  It is invoked when a data model that has\n    * the Sync probe attached calls ```save()``` on a new object.\n    *\n    * @method create_control\n    * @param model {Object} Full data model to save.  This must contain\n    *     the id element.\n    * @param callback {Function(error, result)} Callback when complete\n    *     @param callback.error {Mixed} Set if an error occurs during creation.\n    *     @param callback.result {Object} An object containing any differing\n    *         parameters from the model sent in.  Normally a blank object.\n    */\n    create_control: function(args, callback) {\n      callback({msg: 'not implemented'});\n    },\n\n    /**\n    * Read an instance from storage\n    *\n    * This probe control reads the instance with the specified id\n    * from storage, and returns it in the callback.\n    *\n    * @method read_control\n    * @param id {String} ID of the object to read\n    * @param callback {Function(error, result)} Callback when complete\n    *     @param callback.error {Mixed} Set if an error occurs during read.\n    *       if error.code === 'NOTFOUND' then the requested object wasn't found.\n    *       if error.code === 'PARSE' then the document was poorly formatted JSON.\n    *     @param callback.result {Object} The full object.\n    */\n    read_control: function(args, callback) {\n      callback({msg: 'not implemented'});\n    },\n\n    /**\n    * Update a data model in storage\n    *\n    * This acts like a REST PUT, meaning it can create a new object, or\n    * update an existing object.\n    *\n    * Backbone has only a save() method.  If the client sets the ID\n    * of the object before save(), Backbone thinks the object exists and\n    * will call update vs. create.\n    *\n    * @method update_control\n    * @param model {Object} Full data model to save.  This must contain\n    *     the id element.\n    * @param callback {Function(error, result)} Callback when complete\n    *     @param callback.error {Mixed} Set if an error occurs during save.\n    *     @param callback.result {Object} An object containing any differing\n    *         parameters from the model sent in.  Normally a blank object.\n    */\n    update_control: function(args, callback) {\n      callback({msg: 'not implemented'});\n    },\n\n    /**\n    * Delete an instance from storage\n    *\n    * This probe control deletes the instance with the specified id\n    * from storage.\n    *\n    * @method delete_control\n    * @param id {String} ID of the object to read\n    * @param callback {Function(error)} Callback when complete\n    *     @param callback.error {Mixed} Set if an error occurs during read.\n    */\n    delete_control: function(args, callback) {\n      callback({msg: 'not implemented'});\n    }\n\n  });\n\n  /**\n  * Static Configurations\n  *\n  * These can be set onto the Monitor.SyncProbe class after it's loaded.\n  *\n  * The SyncProbe will *not* work until the defaultProbe is defined.\n  *\n  * Example:\n  *\n  *     var syncConfig = Monitor.SyncProbe.Config;\n  *     syncConfig.defaultProbe = 'FileSyncProbe';\n  *     syncConfig.classMap = {\n  *       Book: 'MongoDbSync',\n  *       Author: 'MongoDbSync'\n  *     }\n  *\n  * @static\n  * @property Config\n  * @type &lt;Object&gt;\n  * <ul>\n  *   <li><code>defaultProbe (String)</code> Name of the sync probe to use if the class isn't listed in the classMap</li>\n  *   <li><code>classMap (Object)</code> Map of className to sync probe name to use instead of the default for that class</li>\n  * </ul>\n  */\n  var defaultConfig = {\n    defaultProbe: '',\n    classMap: {}\n  };\n\n  // Expose default configurations to the config package\n  SyncProbe.Config = _.extend({}, defaultConfig);\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/lib/probes/FileSyncProbe.js":"// FileSyncProbe.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Module loading - this runs server-side only\n  var Monitor = root.Monitor || require('../Monitor'),\n      logger = Monitor.getLogger('FileSyncProbe'),\n      Probe = Monitor.Probe,\n      _ = Monitor._,\n      SyncProbe = Monitor.SyncProbe,\n      FS = require('fs'),\n      Path = require('path'),\n      FileProbe = Monitor.FileProbe;\n\n  // This must be set using setRootPath() before the probe will operate\n  var ROOT_PATH = null;\n\n  /**\n  * Probe for synchronizing a Backbone data model with a file on the O/S\n  *\n  * Probe parameters are listed under <a href=\"SyncProbe.html\">SyncProbe</a>.\n  *\n  * @class FileSyncProbe\n  * @extends Probe\n  * @constructor\n  */\n  var FileSyncProbe = SyncProbe.FileSyncProbe = Probe.extend({\n\n    probeClass: 'FileSyncProbe',\n\n    initialize: function(attributes, options){\n      var t = this;\n      Probe.prototype.initialize.apply(t, arguments);\n\n      // Disable the probe if the root path hasn't been set\n      if (!ROOT_PATH) {\n        throw new Error('FileSync has not been enabled on this server.');\n      }\n\n      // Class name must exist\n      if (!t.has('className')) {\n        throw new Error('FileSync - Class name not specified');\n      }\n\n      // Don't allow a path above the root path\n      t.dirPath = Path.join(ROOT_PATH, t.get('className'));\n      if (t.dirPath.indexOf(ROOT_PATH) !== 0) {\n        throw new Error('Invalid file path');\n      }\n\n      // We're done if this isn't a liveSync probe\n      if (!t.has('modelId')) {\n        return;\n      }\n\n      // Assume callback responsibility\n      options.asyncInit = true;\n      var callback = options.callback;\n\n      // Get the full path to the file\n      t.getFullPath(t.get('modelId'), function(error, response){\n        if (error) {\n          return callback({msg: 'Failed to get the path', err:error});\n        }\n\n        // Get the file and stats\n        var fullPath = response.path;\n        var stats = response.stats;\n\n        // Build the function to watch the file\n        var onFileWatch = function(error, content) {\n\n          var isInitializing = (callback !== null),\n              initCallback = callback;\n          callback = null;\n\n          if (error && error.code === 'ENOENT') {\n            // File doesn't exist. Set the model to null.\n            t.set({model: {}}, {silent: isInitializing});\n            // Convert the code from the sync probe spec\n            error.code = 'NOTFOUND';\n          }\n          if (error) {\n            if (isInitializing) {\n              t.release();\n              var err = {code: error.code, msg: 'LiveSync requires the file to exist and be readable'};\n              initCallback(err);\n            }\n            return;\n          }\n\n          // Parse the JSON content into a JS object.\n          try {\n            content = JSON.parse(content);\n            logger.info('fileParse', {id: t.get('modelId'), content: content});\n          } catch (e) {\n\n            // Fail the probe on first load error\n            if (isInitializing) {\n              t.release();\n              initCallback({code: 'BAD_FORMAT', msg: 'Non-JSON formatted file'});\n            }\n\n            // Nothing productive to do if the file can't be parsed. Just log it.\n            logger.error('fileParse', {error: e, id: t.get('modelId'), content: content});\n            return;\n          }\n\n          // Set the content into the model if it's different\n          // Have to compare raw objects because toJSON returns deep references to models\n          var priorModel = t.get('model');\n          if (!priorModel || !_.isEqual(content, JSON.parse(JSON.stringify(priorModel)))) {\n            t.set({model: content}, {silent: isInitializing});\n          }\n\n          // Call the initialization callback on first load\n          if (isInitializing) {\n            initCallback();\n          }\n        };\n\n        // Load and watch the file\n        var watcherOpts = {\n          preload: true,\n          persistent: true\n        };\n        t.fileWatcher = FileProbe.watchLoad(fullPath, watcherOpts, onFileWatch);\n\n      });\n    },\n\n    // Documentation for these methods in SyncProbe\n    create_control: function(args, callback) {\n      // Make sure the ID exists\n      var t = this, model = args.model;\n      if (!model || !model.id) {\n        return callback({msg:'SyncProbe create - Data model with ID not present'});\n      }\n\n      // Make sure the file doesn't already exist\n      t.getFullPath(model.id, function(error, response) {\n        if (error) {\n          return callback(error);\n        }\n\n        if (response.stats) {\n          return callback({msg:'Document with this ID already exists'});\n        }\n\n        // Forward to the update control\n        t.update_control(args, callback);\n      });\n    },\n\n    read_control: function(args, callback) {\n      // Make sure the ID exists\n      var t = this, id = args.id;\n      if (!id) {\n        return callback({msg:'SyncProbe read - ID not present'});\n      }\n\n      // Read the file\n      t.getFullPath(id, function(error, response){\n        if (error) {\n          return callback(error);\n        }\n        if (!response.stats) {\n          return callback({code: 'NOTFOUND', msg:'Document with this ID not found'});\n        }\n\n        var fullPath = response.path;\n        FS.readFile(fullPath, 'utf8', function(error, data) {\n          if (error) {\n            return callback({code: 'UNKNOWN', msg:'Error reading file', error: error.code});\n          }\n\n          // Parse the file\n          var model;\n          try {\n            model = JSON.parse(data);\n          } catch (e) {\n            return callback({code: 'PARSE', msg: 'Error parsing file'});\n          }\n          callback(null, model);\n        });\n      });\n    },\n\n    update_control: function(args, callback) {\n\n      // Make sure the ID exists\n      var t = this, model = args.model;\n      if (!model || !model.id) {\n        return callback({msg:'SyncProbe create - Data model with ID not present'});\n      }\n\n      // Make sure the directory exists\n      t.getFullPath(model.id, function(error, response) {\n        if (error) {\n          return callback(error);\n        }\n\n        var fullPath = response.path,\n            parentDir = Path.dirname(fullPath);\n        FileProbe.mkdir_r(parentDir, function(error) {\n          if (error) {\n            return callback(error);\n          }\n\n          // Set the contents of the model for liveSync\n          if (t.has('modelId')) {\n            t.set('model', model);\n          }\n\n          // Write the file\n          FS.writeFile(fullPath, JSON.stringify(model, null, 2), 'utf8', function(error){\n            callback(error, {});\n          });\n        });\n      });\n\n    },\n\n    delete_control: function(args, callback) {\n      // Make sure the ID exists\n      var t = this, id = args.id;\n      if (!id) {\n        return callback({msg:'SyncProbe delete - ID not present'});\n      }\n\n      // Set the contents of the model for liveSync\n      t.getFullPath(id, function(error, response) {\n        if (error) {\n          return callback({msg:'Error removing file', err:error});\n        }\n        var fullPath = response.path;\n        if (t.has('modelId')) {\n          t.set('model', null);\n        }\n\n        // Remove the file\n        FS.unlink(fullPath, function(error, data) {\n          if (error) {\n            return callback({msg:'Error removing file'});\n          }\n          return callback(null, {});\n        });\n      });\n    },\n\n    release: function() {\n      var t = this;\n      if (t.fileWatcher) {\n        t.fileWatcher.close();\n        t.fileWatcher = null;\n      }\n    },\n\n    /**\n    * Get the full path to the file\n    *\n    * This builds the full pathname to the file, and performs an fs.sync()\n    * on that pathname, providing the pathname and sync object in the callback.\n    *\n    * @method getFullPath\n    * @param modelId {String} ID of the data model to sync\n    * @param callback {Function(error, return)}\n    *   @param callback.error {Object} Error object (null if no error)\n    *   @param callback.return {Object} return object\n    *     @param callback.return.path {String} Full pathname to the file\n    *     @param callback.return.stat {fs.stats} Stats object (null if the file doesn't esixt)\n    */\n    getFullPath: function(modelId, callback) {\n      var t = this,\n          dirPath = t.dirPath;\n\n      // Don't allow relative paths\n      var fullPath = Path.join(t.dirPath, modelId);\n      if (fullPath.indexOf(dirPath) !== 0) {\n        return callback({msg: 'Model ID ' + modelId + ' cannot represent a relative path'});\n      }\n\n      // See if the path represents a directory\n      FS.stat(fullPath, function(error, stats){\n\n        // If this is an existing directory, return a path to dir/index.json\n        if (!error && stats.isDirectory()) {\n          return t.getFullPath(modelId + '/index', callback);\n        }\n\n        // Normal case - return the path & stat to the json file\n        fullPath += '.json';\n        FS.stat(fullPath, function(error, stats){\n\n          // Not an error if error == ENOENT\n          if (error && error.code === 'ENOENT') {\n            error = null; stats = null;\n          }\n\n          // Process other FS errors\n          if (error) {\n            return callback({err: error, msg: \"Error while observing file: \" + fullPath});\n          }\n\n          // Forward the callback\n          return callback(null, {path: fullPath, stats: stats});\n        });\n      });\n    }\n\n  });\n\n  /**\n  * Set the server root path for objects stored with this probe\n  *\n  * For security purposes, this must be set before the SyncFileProbe\n  * will operate.  It will not accept any changes once set.\n  *\n  * @static\n  * @method setRootPath\n  * @param rootPath {String} A path to the root directory for model object storage\n  */\n  FileSyncProbe.setRootPath = function(rootPath) {\n    var normalized = Path.normalize(rootPath);\n    if (ROOT_PATH && ROOT_PATH !== normalized) {\n      throw new Error('Cannot change the File probe root path once set.');\n    }\n    ROOT_PATH = normalized;\n  };\n\n  /**\n  * Get the current root path.\n  *\n  * As a static method, this is only available on the server running the probe.\n  * For security purposes, this is not exposed in the FileSyncProbe data model.\n  *\n  * @static\n  * @method getRootPath\n  * @return {String} The path to the root directory for the FilePath probe\n  */\n  FileSyncProbe.getRootPath = function() {\n    return ROOT_PATH;\n  };\n\n}(this));\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/config/default.js":"// Default configurations.\nmodule.exports = {\n  Monitor: {\n\n    // This is the running applicaiton name.  It should be overridden\n    // in applications that embed the monitor package.\n    appName: 'Monitor',\n\n    // The base port to use for monitor connections.  If this is changed,\n    // it must be changed on all processes in the monitor network as it\n    // is used by both client and server processes.  Clients use this as\n    // the starting port to scan.  Servers attempt to listen on this port,\n    // and will continue with higher ports if other processes are listening\n    // on the port.\n    serviceBasePort: 42000,\n\n    // When attempting to connect to a remote server, scan this number of\n    // ports on the remote machine (starting at the serviceBasePort) to\n    // discover monitor processes.\n    portsToScan: 20,\n\n    // Only allow connections from this machine by default.  This reduces\n    // accidental security breaches by requiring you to consider your network\n    // security policies before allowing external connections.\n    // See the external.js file in this directory for more information.\n    allowExternalConnections: false,\n\n    // Monitors to start on load.\n    // This is a map of objects, each passed as the first parameter\n    // to a new Monitor instance. The autoStart monitors are named so\n    // additional autoStart monitors can be added in subsequent config files.\n    autoStart: {\n      // monitorName: {probeName: '...', probeClass: '...', initParams:{...}}\n    },\n\n    // Named list of recipe definitions to load when Monitor loads.\n    // See Recipe.js for the structure and behavior of a recipe.\n    recipes: {\n      // recipeName: {recipeDefinition}\n    },\n\n    // Configure the built-in console log output\n    consoleLogListener: {\n      pattern: \"{trace,warn,error,fatal}.*\"\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-monitor/node_modules/monitor/monitor.js":"// monitor.js (c) 2010-2014 Loren West and other contributors\n// May be freely distributed under the MIT license.\n// For further details and documentation:\n// http://lorenwest.github.com/node-monitor\n(function(root){\n\n  // Load dependencies\n  var Monitor = require('./lib/index'),\n      log = Monitor.getLogger('monitor'),\n      stat = Monitor.getStatLogger('monitor'),\n      OS = require('os');\n\n  /**\n  * Bootstrap for a standalone monitor server\n  *\n  * @static\n  * @class server\n  */\n\n  console.log(\"\");\n  console.log(\"                        __________\");\n  console.log(\"_______ ___________________(_)_  /______________ \");\n  console.log(\"__  __ `__ \\\\  __ \\\\_  __ \\\\_  /_  __/  __ \\\\_  ___/\");\n  console.log(\"_  / / / / / /_/ /  / / /  / / /_ / /_/ /  /\");\n  console.log(\"/_/ /_/ /_/\\\\____//_/ /_//_/  \\\\__/ \\\\____//_/\");\n  console.log(\"\");\n\n  // Boot the monitor server.\n  // This accepts websocket connections on the configured port.\n  var server = new Monitor.Server();\n  server.start(function(error) {\n    if (error) {\n      log.error('monitor.start', error);\n      return;\n    }\n\n    var connectTo = Monitor.Config.Monitor.allowExternalConnections ? OS.hostname() : 'localhost';\n    console.log('Monitor service started on host: ' + connectTo);\n\n    // Output security concerns\n    if (!Monitor.Config.Monitor.allowExternalConnections) {\n      console.log(\"\");\n      console.log(\"External connections disabled.\");\n      console.log(\"See \" + process.cwd() + \"/config/external.js for more information.\");\n    }\n\n  });\n\n  // Process uncaught exceptions.\n  process.on('uncaughtException', function(err){\n\n    // On laptop sleep/startup the DNS servers aren't immediately available,\n    // resulting in a flood of these for socket.io until DNS services are back up.\n    if (err.message === 'ECONNREFUSED, Could not contact DNS servers') {\n      return;\n    }\n\n    // Don't allow the process to continue in an unknown state.\n    log.fatal('moniotor.uncaught', 'Uncaught Exception: ' + err.message);\n    log.fatal('moniotor.uncaught', err.stack);\n    server.stop(function(){\n      process.exit(1);\n    });\n\n    // Don't wait around if the server is hung.\n    setTimeout(function(){process.exit(1);}, 2000);\n  });\n\n}(this));\n"}